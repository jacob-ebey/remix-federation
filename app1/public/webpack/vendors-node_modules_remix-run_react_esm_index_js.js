"use strict";
(self["webpackChunkremix_app_template"] = self["webpackChunkremix_app_template"] || []).push([["vendors-node_modules_remix-run_react_esm_index_js"],{

/***/ "./node_modules/@remix-run/react/esm/_virtual/_rollupPluginBabelHelpers.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@remix-run/react/esm/_virtual/_rollupPluginBabelHelpers.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "extends": () => (/* binding */ _extends)
/* harmony export */ });
/**
 * @remix-run/react v1.2.0-pre.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}



/***/ }),

/***/ "./node_modules/@remix-run/react/esm/browser.js":
/*!******************************************************!*\
  !*** ./node_modules/@remix-run/react/esm/browser.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemixBrowser": () => (/* binding */ RemixBrowser)
/* harmony export */ });
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! history */ "./node_modules/history/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components.js */ "./node_modules/@remix-run/react/esm/components.js");
/**
 * @remix-run/react v1.2.0-pre.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */



function RemixBrowser(_props) {
  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  if (historyRef.current == null) {
    historyRef.current = (0,history__WEBPACK_IMPORTED_MODULE_1__.createBrowserHistory)({
      window
    });
  }
  let history = historyRef.current;
  let [state, dispatch] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer((_, update) => update, {
    action: history.action,
    location: history.location
  });
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(dispatch), [history]);
  let entryContext = window.__remixContext;
  entryContext.manifest = window.__remixManifest;
  entryContext.routeModules = window.__remixRouteModules;
  entryContext.appState.trackBoundaries = false;
  entryContext.appState.trackCatchBoundaries = false;
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_js__WEBPACK_IMPORTED_MODULE_2__.RemixEntry, {
    context: entryContext,
    action: state.action,
    location: state.location,
    navigator: history
  });
}



/***/ }),

/***/ "./node_modules/@remix-run/react/esm/components.js":
/*!*********************************************************!*\
  !*** ./node_modules/@remix-run/react/esm/components.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Form": () => (/* binding */ Form),
/* harmony export */   "FormImpl": () => (/* binding */ FormImpl),
/* harmony export */   "Link": () => (/* binding */ Link),
/* harmony export */   "Links": () => (/* binding */ Links),
/* harmony export */   "LiveReload": () => (/* binding */ LiveReload),
/* harmony export */   "Meta": () => (/* binding */ Meta),
/* harmony export */   "NavLink": () => (/* binding */ NavLink),
/* harmony export */   "PrefetchPageLinks": () => (/* binding */ PrefetchPageLinks),
/* harmony export */   "RemixEntry": () => (/* binding */ RemixEntry),
/* harmony export */   "RemixEntryContext": () => (/* binding */ RemixEntryContext),
/* harmony export */   "RemixRoute": () => (/* binding */ RemixRoute),
/* harmony export */   "Scripts": () => (/* binding */ Scripts),
/* harmony export */   "composeEventHandlers": () => (/* binding */ composeEventHandlers),
/* harmony export */   "useActionData": () => (/* binding */ useActionData),
/* harmony export */   "useBeforeUnload": () => (/* binding */ useBeforeUnload),
/* harmony export */   "useFetcher": () => (/* binding */ useFetcher),
/* harmony export */   "useFetchers": () => (/* binding */ useFetchers),
/* harmony export */   "useFormAction": () => (/* binding */ useFormAction),
/* harmony export */   "useLoaderData": () => (/* binding */ useLoaderData),
/* harmony export */   "useMatches": () => (/* binding */ useMatches),
/* harmony export */   "useSubmit": () => (/* binding */ useSubmit),
/* harmony export */   "useSubmitImpl": () => (/* binding */ useSubmitImpl),
/* harmony export */   "useTransition": () => (/* binding */ useTransition)
/* harmony export */ });
/* harmony import */ var _virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_virtual/_rollupPluginBabelHelpers.js */ "./node_modules/@remix-run/react/esm/_virtual/_rollupPluginBabelHelpers.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/index.js");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router-dom/index.js");
/* harmony import */ var _errorBoundaries_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errorBoundaries.js */ "./node_modules/@remix-run/react/esm/errorBoundaries.js");
/* harmony import */ var _invariant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./invariant.js */ "./node_modules/@remix-run/react/esm/invariant.js");
/* harmony import */ var _links_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./links.js */ "./node_modules/@remix-run/react/esm/links.js");
/* harmony import */ var _markup_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./markup.js */ "./node_modules/@remix-run/react/esm/markup.js");
/* harmony import */ var _routes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./routes.js */ "./node_modules/@remix-run/react/esm/routes.js");
/* harmony import */ var _routeMatching_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./routeMatching.js */ "./node_modules/@remix-run/react/esm/routeMatching.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transition.js */ "./node_modules/@remix-run/react/esm/transition.js");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
/**
 * @remix-run/react v1.2.0-pre.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */










const RemixEntryContext = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);
function useRemixEntryContext() {
  let context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RemixEntryContext);
  (0,_invariant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(context, "You must render this element inside a <Remix> element");
  return context;
}
function RemixEntry({
  context: entryContext,
  action,
  location: historyLocation,
  navigator: _navigator,
  static: staticProp = false
}) {
  let {
    manifest,
    routeData: documentLoaderData,
    actionData: documentActionData,
    routeModules,
    serverHandoffString,
    appState: entryComponentDidCatchEmulator
  } = entryContext;
  let clientRoutes = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_routes_js__WEBPACK_IMPORTED_MODULE_2__.createClientRoutes)(manifest.routes, routeModules, RemixRoute), [manifest, routeModules]);
  let [clientState, setClientState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(entryComponentDidCatchEmulator);
  let [transitionManager] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => {
    return (0,_transition_js__WEBPACK_IMPORTED_MODULE_3__.createTransitionManager)({
      routes: clientRoutes,
      actionData: documentActionData,
      loaderData: documentLoaderData,
      location: historyLocation,
      catch: entryComponentDidCatchEmulator.catch,
      catchBoundaryId: entryComponentDidCatchEmulator.catchBoundaryRouteId,
      onRedirect: _navigator.replace,
      onChange: (state) => {
        setClientState({
          catch: state.catch,
          error: state.error,
          catchBoundaryRouteId: state.catchBoundaryId,
          loaderBoundaryRouteId: state.errorBoundaryId,
          renderBoundaryRouteId: null,
          trackBoundaries: false,
          trackCatchBoundaries: false
        });
      }
    });
  });
  let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let push = (to, state) => {
      return transitionManager.getState().transition.state !== "idle" ? _navigator.replace(to, state) : _navigator.push(to, state);
    };
    return __spreadProps(__spreadValues({}, _navigator), {
      push
    });
  }, [_navigator, transitionManager]);
  let {
    location,
    matches,
    loaderData,
    actionData
  } = transitionManager.getState();
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let {
      location: location2
    } = transitionManager.getState();
    if (historyLocation === location2)
      return;
    transitionManager.send({
      type: "navigation",
      location: historyLocation,
      submission: consumeNextNavigationSubmission(),
      action
    });
  }, [transitionManager, historyLocation, action]);
  let ssrErrorBeforeRoutesRendered = clientState.error && clientState.renderBoundaryRouteId === null && clientState.loaderBoundaryRouteId === null ? deserializeError(clientState.error) : void 0;
  let ssrCatchBeforeRoutesRendered = clientState.catch && clientState.catchBoundaryRouteId === null ? clientState.catch : void 0;
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RemixEntryContext.Provider, {
    value: {
      matches,
      manifest,
      appState: clientState,
      routeModules,
      serverHandoffString,
      clientRoutes,
      routeData: loaderData,
      actionData,
      transitionManager
    }
  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_errorBoundaries_js__WEBPACK_IMPORTED_MODULE_4__.RemixErrorBoundary, {
    location,
    component: _errorBoundaries_js__WEBPACK_IMPORTED_MODULE_4__.RemixRootDefaultErrorBoundary,
    error: ssrErrorBeforeRoutesRendered
  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_errorBoundaries_js__WEBPACK_IMPORTED_MODULE_4__.RemixCatchBoundary, {
    location,
    component: _errorBoundaries_js__WEBPACK_IMPORTED_MODULE_4__.RemixRootDefaultCatchBoundary,
    catch: ssrCatchBeforeRoutesRendered
  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Router, {
    navigationType: action,
    location,
    navigator,
    static: staticProp
  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Routes, null)))));
}
function deserializeError(data) {
  let error = new Error(data.message);
  error.stack = data.stack;
  return error;
}
function Routes() {
  let {
    clientRoutes
  } = useRemixEntryContext();
  let element = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_5__.useRoutes)(clientRoutes) || clientRoutes[0].element;
  return element;
}
const RemixRouteContext = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);
function useRemixRouteContext() {
  let context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RemixRouteContext);
  (0,_invariant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(context, "You must render this element in a remix route element");
  return context;
}
function DefaultRouteComponent({
  id
}) {
  throw new Error(`Route "${id}" has no component! Please go add a \`default\` export in the route module file.
If you were trying to navigate or submit to a resource route, use \`<a>\` instead of \`<Link>\` or \`<Form reloadDocument>\`.`);
}
function RemixRoute({
  id
}) {
  let location = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_5__.useLocation)();
  let {
    routeData,
    routeModules,
    appState
  } = useRemixEntryContext();
  let data = routeData[id];
  let {
    default: Component,
    CatchBoundary,
    ErrorBoundary
  } = routeModules[id];
  let element = Component ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, null) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultRouteComponent, {
    id
  });
  let context = {
    data,
    id
  };
  if (CatchBoundary) {
    let maybeServerCaught = appState.catch && appState.catchBoundaryRouteId === id ? appState.catch : void 0;
    if (appState.trackCatchBoundaries) {
      appState.catchBoundaryRouteId = id;
    }
    context = maybeServerCaught ? {
      id,
      get data() {
        console.error("You cannot `useLoaderData` in a catch boundary.");
        return void 0;
      }
    } : {
      id,
      data
    };
    element = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_errorBoundaries_js__WEBPACK_IMPORTED_MODULE_4__.RemixCatchBoundary, {
      location,
      component: CatchBoundary,
      catch: maybeServerCaught
    }, element);
  }
  if (ErrorBoundary) {
    let maybeServerRenderError = appState.error && (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id) ? deserializeError(appState.error) : void 0;
    if (appState.trackBoundaries) {
      appState.renderBoundaryRouteId = id;
    }
    context = maybeServerRenderError ? {
      id,
      get data() {
        console.error("You cannot `useLoaderData` in an error boundary.");
        return void 0;
      }
    } : {
      id,
      data
    };
    element = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_errorBoundaries_js__WEBPACK_IMPORTED_MODULE_4__.RemixErrorBoundary, {
      location,
      component: ErrorBoundary,
      error: maybeServerRenderError
    }, element);
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RemixRouteContext.Provider, {
    value: context
  }, element);
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let [maybePrefetch, setMaybePrefetch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  let [shouldPrefetch, setShouldPrefetch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  let {
    onFocus,
    onBlur,
    onMouseEnter,
    onMouseLeave,
    onTouchStart
  } = theirElementProps;
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
  }, [prefetch]);
  let setIntent = () => {
    if (prefetch === "intent") {
      setMaybePrefetch(true);
    }
  };
  let cancelIntent = () => {
    if (prefetch === "intent") {
      setMaybePrefetch(false);
    }
  };
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]);
  return [shouldPrefetch, {
    onFocus: composeEventHandlers(onFocus, setIntent),
    onBlur: composeEventHandlers(onBlur, cancelIntent),
    onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
    onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
    onTouchStart: composeEventHandlers(onTouchStart, setIntent)
  }];
}
let NavLink = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((_a, forwardedRef) => {
  var _b = _a, {
    to,
    prefetch = "none"
  } = _b, props = __objRest(_b, [
    "to",
    "prefetch"
  ]);
  let href = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_5__.useHref)(to);
  let [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_6__.NavLink, (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__["extends"])({
    ref: forwardedRef,
    to
  }, props, prefetchHandlers)), shouldPrefetch ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinks, {
    page: href
  }) : null);
});
let Link = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((_c, forwardedRef) => {
  var _d = _c, {
    to,
    prefetch = "none"
  } = _d, props = __objRest(_d, [
    "to",
    "prefetch"
  ]);
  let href = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_5__.useHref)(to);
  let [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router_dom__WEBPACK_IMPORTED_MODULE_6__.Link, (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__["extends"])({
    ref: forwardedRef,
    to
  }, props, prefetchHandlers)), shouldPrefetch ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinks, {
    page: href
  }) : null);
});
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function Links() {
  let {
    matches,
    routeModules,
    manifest
  } = useRemixEntryContext();
  let links = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_links_js__WEBPACK_IMPORTED_MODULE_8__.getLinksForMatches)(matches, routeModules, manifest), [matches, routeModules, manifest]);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, links.map((link) => (0,_links_js__WEBPACK_IMPORTED_MODULE_8__.isPageLinkDescriptor)(link) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinks, (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__["extends"])({
    key: link.page
  }, link)) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__["extends"])({
    key: link.rel + link.href
  }, link))));
}
function PrefetchPageLinks(_e) {
  var _f = _e, {
    page
  } = _f, dataLinkProps = __objRest(_f, [
    "page"
  ]);
  let {
    clientRoutes
  } = useRemixEntryContext();
  let matches = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_routeMatching_js__WEBPACK_IMPORTED_MODULE_9__.matchClientRoutes)(clientRoutes, page), [clientRoutes, page]);
  if (!matches) {
    console.warn(`Tried to prefetch ${page} but no routes matched.`);
    return null;
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinksImpl, (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__["extends"])({
    page,
    matches
  }, dataLinkProps));
}
function usePrefetchedStylesheets(matches) {
  let {
    routeModules
  } = useRemixEntryContext();
  let [styleLinks, setStyleLinks] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let interrupted = false;
    (0,_links_js__WEBPACK_IMPORTED_MODULE_8__.getStylesheetPrefetchLinks)(matches, routeModules).then((links) => {
      if (!interrupted)
        setStyleLinks(links);
    });
    return () => {
      interrupted = true;
    };
  }, [matches, routeModules]);
  return styleLinks;
}
function PrefetchPageLinksImpl(_g) {
  var _h = _g, {
    page,
    matches: nextMatches
  } = _h, linkProps = __objRest(_h, [
    "page",
    "matches"
  ]);
  let location = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_5__.useLocation)();
  let {
    matches,
    manifest
  } = useRemixEntryContext();
  let newMatchesForData = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_links_js__WEBPACK_IMPORTED_MODULE_8__.getNewMatchesForLinks)(page, nextMatches, matches, location, "data"), [page, nextMatches, matches, location]);
  let newMatchesForAssets = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_links_js__WEBPACK_IMPORTED_MODULE_8__.getNewMatchesForLinks)(page, nextMatches, matches, location, "assets"), [page, nextMatches, matches, location]);
  let dataHrefs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_links_js__WEBPACK_IMPORTED_MODULE_8__.getDataLinkHrefs)(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]);
  let moduleHrefs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => (0,_links_js__WEBPACK_IMPORTED_MODULE_8__.getModuleLinkHrefs)(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]);
  let styleLinks = usePrefetchedStylesheets(newMatchesForAssets);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__["extends"])({
    key: href,
    rel: "prefetch",
    as: "fetch",
    href
  }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__["extends"])({
    key: href,
    rel: "modulepreload",
    href
  }, linkProps))), styleLinks.map((link) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__["extends"])({
    key: link.href
  }, link))));
}
function Meta() {
  let {
    matches,
    routeData,
    routeModules
  } = useRemixEntryContext();
  let location = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_5__.useLocation)();
  let meta = {};
  let parentsData = {};
  for (let match of matches) {
    let routeId = match.route.id;
    let data = routeData[routeId];
    let params = match.params;
    let routeModule = routeModules[routeId];
    if (routeModule.meta) {
      let routeMeta = typeof routeModule.meta === "function" ? routeModule.meta({
        data,
        parentsData,
        params,
        location
      }) : routeModule.meta;
      Object.assign(meta, routeMeta);
    }
    parentsData[routeId] = data;
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, Object.entries(meta).map(([name, value]) => {
    let isOpenGraphTag = name.startsWith("og:");
    return name === "title" ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("title", {
      key: "title"
    }, value) : Array.isArray(value) ? value.map((content) => isOpenGraphTag ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("meta", {
      key: name + content,
      property: name,
      content
    }) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("meta", {
      key: name + content,
      name,
      content
    })) : isOpenGraphTag ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("meta", {
      key: name,
      property: name,
      content: value
    }) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("meta", {
      key: name,
      name,
      content: value
    });
  }));
}
let isHydrated = false;
function Scripts(props) {
  let {
    manifest,
    matches,
    pendingLocation,
    clientRoutes,
    serverHandoffString
  } = useRemixEntryContext();
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    isHydrated = true;
  }, []);
  let initialScripts = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let contextScript = serverHandoffString ? `window.__remixContext = ${serverHandoffString};` : "";
    let routeModulesScript = `${matches.map((match, index) => `import * as route${index} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join("\n")}
window.__remixRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};`;
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__["extends"])({}, props, {
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: (0,_markup_js__WEBPACK_IMPORTED_MODULE_10__.createHtml)(contextScript)
    })), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__["extends"])({}, props, {
      src: manifest.url
    })), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__["extends"])({}, props, {
      dangerouslySetInnerHTML: (0,_markup_js__WEBPACK_IMPORTED_MODULE_10__.createHtml)(routeModulesScript),
      type: "module"
    })), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__["extends"])({}, props, {
      src: manifest.entry.module,
      type: "module"
    })));
  }, []);
  let nextMatches = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (pendingLocation) {
      let matches2 = (0,_routeMatching_js__WEBPACK_IMPORTED_MODULE_9__.matchClientRoutes)(clientRoutes, pendingLocation);
      (0,_invariant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(matches2, `No routes match path "${pendingLocation.pathname}"`);
      return matches2;
    }
    return [];
  }, [pendingLocation, clientRoutes]);
  let routePreloads = matches.concat(nextMatches).map((match) => {
    let route = manifest.routes[match.route.id];
    return (route.imports || []).concat([route.module]);
  }).flat(1);
  let preloads = manifest.entry.imports.concat(routePreloads);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, dedupe(preloads).map((path) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", {
    key: path,
    rel: "modulepreload",
    href: path,
    crossOrigin: props.crossOrigin
  })), isHydrated ? null : initialScripts);
}
function dedupe(array) {
  return [...new Set(array)];
}
let Form = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormImpl, (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__["extends"])({}, props, {
    ref
  }));
});
let FormImpl = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((_i, forwardedRef) => {
  var _j = _i, {
    reloadDocument = false,
    replace = false,
    method = "get",
    action = ".",
    encType = "application/x-www-form-urlencoded",
    fetchKey,
    onSubmit
  } = _j, props = __objRest(_j, [
    "reloadDocument",
    "replace",
    "method",
    "action",
    "encType",
    "fetchKey",
    "onSubmit"
  ]);
  let submit = useSubmitImpl(fetchKey);
  let formMethod = method.toLowerCase() === "get" ? "get" : "post";
  let formAction = useFormAction(action, formMethod);
  let formRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  let ref = useComposedRefs(forwardedRef, formRef);
  let clickedButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let form = formRef.current;
    if (!form)
      return;
    function handleClick(event) {
      if (!(event.target instanceof Element))
        return;
      let submitButton = event.target.closest("button,input[type=submit]");
      if (submitButton && submitButton.form === form && submitButton.type === "submit") {
        clickedButtonRef.current = submitButton;
      }
    }
    window.addEventListener("click", handleClick);
    return () => {
      window.removeEventListener("click", handleClick);
    };
  }, []);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("form", (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__["extends"])({
    ref,
    method: formMethod,
    action: formAction,
    encType,
    onSubmit: reloadDocument ? void 0 : (event) => {
      onSubmit && onSubmit(event);
      if (event.defaultPrevented)
        return;
      event.preventDefault();
      submit(clickedButtonRef.current || event.currentTarget, {
        method,
        replace
      });
      clickedButtonRef.current = null;
    }
  }, props));
});
function isActionRequestMethod(method) {
  method = method.toLowerCase();
  return method === "post" || method === "put" || method === "patch" || method === "delete";
}
function useFormAction(action = ".", method = "get") {
  let {
    id
  } = useRemixRouteContext();
  let path = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_5__.useResolvedPath)(action);
  let search = path.search;
  let isIndexRoute = id.endsWith("/index");
  if (action === "." && isIndexRoute && isActionRequestMethod(method)) {
    search = search ? search.replace(/^\?/, "?index&") : "?index";
  }
  return path.pathname + search;
}
function useSubmit() {
  return useSubmitImpl();
}
function useSubmitImpl(key) {
  let navigate = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_5__.useNavigate)();
  let defaultAction = useFormAction();
  let {
    transitionManager
  } = useRemixEntryContext();
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((target, options = {}) => {
    let method;
    let action;
    let encType;
    let formData;
    if (isFormElement(target)) {
      let submissionTrigger = options.submissionTrigger;
      method = options.method || target.method;
      action = options.action || target.action;
      encType = options.encType || target.enctype;
      formData = new FormData(target);
      if (submissionTrigger && submissionTrigger.name) {
        formData.append(submissionTrigger.name, submissionTrigger.value);
      }
    } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
      let form = target.form;
      if (form == null) {
        throw new Error(`Cannot submit a <button> without a <form>`);
      }
      method = options.method || target.getAttribute("formmethod") || form.method;
      action = options.action || target.getAttribute("formaction") || form.action;
      encType = options.encType || target.getAttribute("formenctype") || form.enctype;
      formData = new FormData(form);
      if (target.name) {
        formData.set(target.name, target.value);
      }
    } else {
      if (isHtmlElement(target)) {
        throw new Error(`Cannot submit element that is not <form>, <button>, or <input type="submit|image">`);
      }
      method = options.method || "get";
      action = options.action || defaultAction;
      encType = options.encType || "application/x-www-form-urlencoded";
      if (target instanceof FormData) {
        formData = target;
      } else {
        formData = new FormData();
        if (target instanceof URLSearchParams) {
          for (let [name, value] of target) {
            formData.append(name, value);
          }
        } else if (target != null) {
          for (let name of Object.keys(target)) {
            formData.append(name, target[name]);
          }
        }
      }
    }
    if (typeof window === "undefined") {
      throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
    }
    let {
      protocol,
      host
    } = window.location;
    let url = new URL(action, `${protocol}//${host}`);
    if (method.toLowerCase() === "get") {
      for (let [name, value] of formData) {
        if (typeof value === "string") {
          url.searchParams.append(name, value);
        } else {
          throw new Error(`Cannot submit binary form data using GET`);
        }
      }
    }
    let submission = {
      formData,
      action: url.pathname + url.search,
      method: method.toUpperCase(),
      encType,
      key: Math.random().toString(36).substr(2, 8)
    };
    if (key) {
      transitionManager.send({
        type: "fetcher",
        href: submission.action,
        submission,
        key
      });
    } else {
      setNextNavigationSubmission(submission);
      navigate(url.pathname + url.search, {
        replace: options.replace
      });
    }
  }, [defaultAction, key, navigate, transitionManager]);
}
let nextNavigationSubmission;
function setNextNavigationSubmission(submission) {
  nextNavigationSubmission = submission;
}
function consumeNextNavigationSubmission() {
  let submission = nextNavigationSubmission;
  nextNavigationSubmission = void 0;
  return submission;
}
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function useBeforeUnload(callback) {
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    window.addEventListener("beforeunload", callback);
    return () => {
      window.removeEventListener("beforeunload", callback);
    };
  }, [callback]);
}
function useMatches() {
  let {
    matches,
    routeData,
    routeModules
  } = useRemixEntryContext();
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => matches.map((match) => {
    var _routeModules$match$r;
    let {
      pathname,
      params
    } = match;
    return {
      id: match.route.id,
      pathname,
      params,
      data: routeData[match.route.id],
      handle: (_routeModules$match$r = routeModules[match.route.id]) === null || _routeModules$match$r === void 0 ? void 0 : _routeModules$match$r.handle
    };
  }), [matches, routeData, routeModules]);
}
function useLoaderData() {
  return useRemixRouteContext().data;
}
function useActionData() {
  let {
    id: routeId
  } = useRemixRouteContext();
  let {
    transitionManager
  } = useRemixEntryContext();
  let {
    actionData
  } = transitionManager.getState();
  return actionData ? actionData[routeId] : void 0;
}
function useTransition() {
  let {
    transitionManager
  } = useRemixEntryContext();
  return transitionManager.getState().transition;
}
function createFetcherForm(fetchKey) {
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FormImpl, (0,_virtual_rollupPluginBabelHelpers_js__WEBPACK_IMPORTED_MODULE_7__["extends"])({}, props, {
      ref,
      fetchKey
    }));
  });
}
let fetcherId = 0;
function useFetcher() {
  let {
    transitionManager
  } = useRemixEntryContext();
  let [key] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => String(++fetcherId));
  let [Form2] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => createFetcherForm(key));
  let [load] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => (href) => {
    transitionManager.send({
      type: "fetcher",
      href,
      key
    });
  });
  let submit = useSubmitImpl(key);
  let fetcher = transitionManager.getFetcher(key);
  let fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => __spreadValues({
    Form: Form2,
    submit,
    load
  }, fetcher), [fetcher, Form2, submit, load]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    return () => transitionManager.deleteFetcher(key);
  }, [transitionManager, key]);
  return fetcherWithComponents;
}
function useFetchers() {
  let {
    transitionManager
  } = useRemixEntryContext();
  let {
    fetchers
  } = transitionManager.getState();
  return [...fetchers.values()];
}
const LiveReload =  false ? 0 : function LiveReload2({
  port = Number(process.env.REMIX_DEV_SERVER_WS_PORT || 8002)
}) {
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
let protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
let host = location.hostname;
let socketPath = protocol + '//' + host + ':${port}/socket';

let ws = new WebSocket(socketPath);
ws.onmessage = message => {
  let event = JSON.parse(message.data);
  if (event.type === "LOG") {
    console.log(event.message);
  }
  if (event.type === "RELOAD") {
    console.log("\u{1F4BF} Reloading window ...");
    window.location.reload();
  }
};
ws.onerror = error => {
  console.log("Remix dev asset server web socket error:");
  console.error(error);
};
              `.trim()
    }
  });
};
function useComposedRefs(...refs) {
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node) => {
    for (let ref of refs) {
      if (ref == null)
        continue;
      if (typeof ref === "function") {
        ref(node);
      } else {
        try {
          ref.current = node;
        } catch (_) {
        }
      }
    }
  }, refs);
}



/***/ }),

/***/ "./node_modules/@remix-run/react/esm/data.js":
/*!***************************************************!*\
  !*** ./node_modules/@remix-run/react/esm/data.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "extractData": () => (/* binding */ extractData),
/* harmony export */   "fetchData": () => (/* binding */ fetchData),
/* harmony export */   "isCatchResponse": () => (/* binding */ isCatchResponse),
/* harmony export */   "isErrorResponse": () => (/* binding */ isErrorResponse),
/* harmony export */   "isRedirectResponse": () => (/* binding */ isRedirectResponse)
/* harmony export */ });
/* harmony import */ var _invariant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./invariant.js */ "./node_modules/@remix-run/react/esm/invariant.js");
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
/**
 * @remix-run/react v1.2.0-pre.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */

function isCatchResponse(response) {
  return response instanceof Response && response.headers.get("X-Remix-Catch") != null;
}
function isErrorResponse(response) {
  return response instanceof Response && response.headers.get("X-Remix-Error") != null;
}
function isRedirectResponse(response) {
  return response instanceof Response && response.headers.get("X-Remix-Redirect") != null;
}
function fetchData(url, routeId, signal, submission) {
  return __async(this, null, function* () {
    url.searchParams.set("_data", routeId);
    let init = submission ? getActionInit(submission, signal) : {
      credentials: "same-origin",
      signal
    };
    let response = yield fetch(url.href, init);
    if (isErrorResponse(response)) {
      let data = yield response.json();
      let error = new Error(data.message);
      error.stack = data.stack;
      return error;
    }
    return response;
  });
}
function extractData(response) {
  return __async(this, null, function* () {
    let contentType = response.headers.get("Content-Type");
    if (contentType && /\bapplication\/json\b/.test(contentType)) {
      return response.json();
    }
    return response.text();
  });
}
function getActionInit(submission, signal) {
  let {
    encType,
    method,
    formData
  } = submission;
  let headers = void 0;
  let body = formData;
  if (encType === "application/x-www-form-urlencoded") {
    body = new URLSearchParams();
    for (let [key, value] of formData) {
      (0,_invariant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof value === "string", `File inputs are not supported with encType "application/x-www-form-urlencoded", please use "multipart/form-data" instead.`);
      body.append(key, value);
    }
    headers = {
      "Content-Type": encType
    };
  }
  return {
    method,
    body,
    signal,
    credentials: "same-origin",
    headers
  };
}



/***/ }),

/***/ "./node_modules/@remix-run/react/esm/errorBoundaries.js":
/*!**************************************************************!*\
  !*** ./node_modules/@remix-run/react/esm/errorBoundaries.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemixCatchBoundary": () => (/* binding */ RemixCatchBoundary),
/* harmony export */   "RemixErrorBoundary": () => (/* binding */ RemixErrorBoundary),
/* harmony export */   "RemixRootDefaultCatchBoundary": () => (/* binding */ RemixRootDefaultCatchBoundary),
/* harmony export */   "RemixRootDefaultErrorBoundary": () => (/* binding */ RemixRootDefaultErrorBoundary),
/* harmony export */   "useCatch": () => (/* binding */ useCatch)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @remix-run/react v1.2.0-pre.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */

class RemixErrorBoundary extends (react__WEBPACK_IMPORTED_MODULE_0___default().Component) {
  constructor(props) {
    super(props);
    this.state = {
      error: props.error || null,
      location: props.location
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return {
        error: props.error || null,
        location: props.location
      };
    }
    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  render() {
    if (this.state.error) {
      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(this.props.component, {
        error: this.state.error
      });
    } else {
      return this.props.children;
    }
  }
}
function RemixRootDefaultErrorBoundary({
  error
}) {
  console.error(error);
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("head", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("title", null, "Application Error!")), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("body", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("main", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("h1", {
    style: {
      fontSize: "24px"
    }
  }, "Application Error"), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("pre", {
    style: {
      padding: "2rem",
      background: "hsla(10, 50%, 50%, 0.1)",
      color: "red",
      overflow: "auto"
    }
  }, error.stack)), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
              );
            `
    }
  })));
}
let RemixCatchContext = /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(void 0);
function useCatch() {
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RemixCatchContext);
}
function RemixCatchBoundary({
  catch: catchVal,
  component: Component,
  children
}) {
  if (catchVal) {
    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RemixCatchContext.Provider, {
      value: catchVal
    }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Component, null));
  }
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null, children);
}
function RemixRootDefaultCatchBoundary() {
  let caught = useCatch();
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("head", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("title", null, "Unhandled Thrown Response!")), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("body", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("h1", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, caught.status, " ", caught.statusText), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0___default().createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws 404s (and other responses). Check out https://remix.run/guides/not-found for more information."
              );
            `
    }
  })));
}



/***/ }),

/***/ "./node_modules/@remix-run/react/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@remix-run/react/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemixBrowser": () => (/* reexport safe */ _browser_js__WEBPACK_IMPORTED_MODULE_0__.RemixBrowser),
/* harmony export */   "Outlet": () => (/* reexport safe */ react_router_dom__WEBPACK_IMPORTED_MODULE_1__.Outlet),
/* harmony export */   "useHref": () => (/* reexport safe */ react_router_dom__WEBPACK_IMPORTED_MODULE_1__.useHref),
/* harmony export */   "useLocation": () => (/* reexport safe */ react_router_dom__WEBPACK_IMPORTED_MODULE_1__.useLocation),
/* harmony export */   "useNavigate": () => (/* reexport safe */ react_router_dom__WEBPACK_IMPORTED_MODULE_1__.useNavigate),
/* harmony export */   "useNavigationType": () => (/* reexport safe */ react_router_dom__WEBPACK_IMPORTED_MODULE_1__.useNavigationType),
/* harmony export */   "useOutlet": () => (/* reexport safe */ react_router_dom__WEBPACK_IMPORTED_MODULE_1__.useOutlet),
/* harmony export */   "useOutletContext": () => (/* reexport safe */ react_router_dom__WEBPACK_IMPORTED_MODULE_1__.useOutletContext),
/* harmony export */   "useParams": () => (/* reexport safe */ react_router_dom__WEBPACK_IMPORTED_MODULE_1__.useParams),
/* harmony export */   "useResolvedPath": () => (/* reexport safe */ react_router_dom__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath),
/* harmony export */   "useSearchParams": () => (/* reexport safe */ react_router_dom__WEBPACK_IMPORTED_MODULE_2__.useSearchParams),
/* harmony export */   "Form": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.Form),
/* harmony export */   "Link": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.Link),
/* harmony export */   "Links": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.Links),
/* harmony export */   "LiveReload": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.LiveReload),
/* harmony export */   "Meta": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.Meta),
/* harmony export */   "NavLink": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.NavLink),
/* harmony export */   "PrefetchPageLinks": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.PrefetchPageLinks),
/* harmony export */   "Scripts": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.Scripts),
/* harmony export */   "useActionData": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.useActionData),
/* harmony export */   "useBeforeUnload": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.useBeforeUnload),
/* harmony export */   "useFetcher": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.useFetcher),
/* harmony export */   "useFetchers": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.useFetchers),
/* harmony export */   "useFormAction": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.useFormAction),
/* harmony export */   "useLoaderData": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.useLoaderData),
/* harmony export */   "useMatches": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.useMatches),
/* harmony export */   "useSubmit": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.useSubmit),
/* harmony export */   "useTransition": () => (/* reexport safe */ _components_js__WEBPACK_IMPORTED_MODULE_3__.useTransition),
/* harmony export */   "useCatch": () => (/* reexport safe */ _errorBoundaries_js__WEBPACK_IMPORTED_MODULE_4__.useCatch),
/* harmony export */   "ScrollRestoration": () => (/* reexport safe */ _scroll_restoration_js__WEBPACK_IMPORTED_MODULE_5__.ScrollRestoration),
/* harmony export */   "RemixServer": () => (/* reexport safe */ _server_js__WEBPACK_IMPORTED_MODULE_6__.RemixServer)
/* harmony export */ });
/* harmony import */ var _browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browser.js */ "./node_modules/@remix-run/react/esm/browser.js");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/index.js");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router-dom/index.js");
/* harmony import */ var _components_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components.js */ "./node_modules/@remix-run/react/esm/components.js");
/* harmony import */ var _errorBoundaries_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errorBoundaries.js */ "./node_modules/@remix-run/react/esm/errorBoundaries.js");
/* harmony import */ var _scroll_restoration_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scroll-restoration.js */ "./node_modules/@remix-run/react/esm/scroll-restoration.js");
/* harmony import */ var _server_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./server.js */ "./node_modules/@remix-run/react/esm/server.js");
/**
 * @remix-run/react v1.2.0-pre.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */








/***/ }),

/***/ "./node_modules/@remix-run/react/esm/invariant.js":
/*!********************************************************!*\
  !*** ./node_modules/@remix-run/react/esm/invariant.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ invariant)
/* harmony export */ });
/**
 * @remix-run/react v1.2.0-pre.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}



/***/ }),

/***/ "./node_modules/@remix-run/react/esm/links.js":
/*!****************************************************!*\
  !*** ./node_modules/@remix-run/react/esm/links.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dedupe": () => (/* binding */ dedupe),
/* harmony export */   "getDataLinkHrefs": () => (/* binding */ getDataLinkHrefs),
/* harmony export */   "getLinksForMatches": () => (/* binding */ getLinksForMatches),
/* harmony export */   "getModuleLinkHrefs": () => (/* binding */ getModuleLinkHrefs),
/* harmony export */   "getNewMatchesForLinks": () => (/* binding */ getNewMatchesForLinks),
/* harmony export */   "getStylesheetPrefetchLinks": () => (/* binding */ getStylesheetPrefetchLinks),
/* harmony export */   "isHtmlLinkDescriptor": () => (/* binding */ isHtmlLinkDescriptor),
/* harmony export */   "isPageLinkDescriptor": () => (/* binding */ isPageLinkDescriptor),
/* harmony export */   "prefetchStyleLinks": () => (/* binding */ prefetchStyleLinks)
/* harmony export */ });
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! history */ "./node_modules/history/index.js");
/* harmony import */ var _routeModules_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./routeModules.js */ "./node_modules/@remix-run/react/esm/routeModules.js");
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
/**
 * @remix-run/react v1.2.0-pre.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */


function getLinksForMatches(matches, routeModules, manifest) {
  let descriptors = matches.map((match) => {
    var _module$links;
    let module = routeModules[match.route.id];
    return ((_module$links = module.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module)) || [];
  }).flat(1);
  let preloads = getCurrentPageModulePreloadHrefs(matches, manifest);
  return dedupe(descriptors, preloads);
}
function prefetchStyleLinks(routeModule) {
  return __async(this, null, function* () {
    if (!routeModule.links)
      return;
    let descriptors = routeModule.links();
    if (!descriptors)
      return;
    let styleLinks = [];
    for (let descriptor of descriptors) {
      if (!isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet") {
        styleLinks.push(__spreadProps(__spreadValues({}, descriptor), {
          rel: "preload",
          as: "style"
        }));
      }
    }
    let matchingLinks = styleLinks.filter((link) => !link.media || window.matchMedia(link.media).matches);
    yield Promise.all(matchingLinks.map(prefetchStyleLink));
  });
}
function prefetchStyleLink(descriptor) {
  return __async(this, null, function* () {
    return new Promise((resolve) => {
      let link = document.createElement("link");
      Object.assign(link, descriptor);
      function removeLink() {
        if (document.head.contains(link)) {
          document.head.removeChild(link);
        }
      }
      link.onload = () => {
        removeLink();
        resolve();
      };
      link.onerror = () => {
        removeLink();
        resolve();
      };
      document.head.appendChild(link);
    });
  });
}
function isPageLinkDescriptor(object) {
  return object != null && typeof object.page === "string";
}
function isHtmlLinkDescriptor(object) {
  return object != null && typeof object.rel === "string" && typeof object.href === "string";
}
function getStylesheetPrefetchLinks(matches, routeModules) {
  return __async(this, null, function* () {
    let links = yield Promise.all(matches.map((match) => __async(this, null, function* () {
      let mod = yield (0,_routeModules_js__WEBPACK_IMPORTED_MODULE_0__.loadRouteModule)(match.route, routeModules);
      return mod.links ? mod.links() : [];
    })));
    return links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map((_a) => {
      var _b = _a, {
        rel
      } = _b, attrs = __objRest(_b, [
        "rel"
      ]);
      return rel === "preload" ? __spreadValues({
        rel: "prefetch"
      }, attrs) : __spreadValues({
        rel: "prefetch",
        as: "style"
      }, attrs);
    });
  });
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, location, mode) {
  let path = parsePathPatch(page);
  let isNew = (match, index) => {
    if (!currentMatches[index])
      return true;
    return match.route.id !== currentMatches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    var _currentMatches$index;
    return currentMatches[index].pathname !== match.pathname || ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index].params["*"] !== match.params["*"];
  };
  let newMatches = mode === "data" && location.search !== path.search ? nextMatches.filter((match, index) => {
    if (!match.route.hasLoader) {
      return false;
    }
    if (isNew(match, index) || matchPathChanged(match, index)) {
      return true;
    }
    if (match.route.shouldReload) {
      return match.route.shouldReload({
        params: match.params,
        prevUrl: new URL(location.pathname + location.search + location.hash, window.origin),
        url: new URL(page, window.origin)
      });
    }
    return true;
  }) : nextMatches.filter((match, index) => {
    return match.route.hasLoader && (isNew(match, index) || matchPathChanged(match, index));
  });
  return newMatches;
}
function getDataLinkHrefs(page, matches, manifest) {
  let path = parsePathPatch(page);
  return dedupeHrefs(matches.filter((match) => manifest.routes[match.route.id].hasLoader).map((match) => {
    let {
      pathname,
      search
    } = path;
    let searchParams = new URLSearchParams(search);
    searchParams.set("_data", match.route.id);
    return `${pathname}?${searchParams}`;
  }));
}
function getModuleLinkHrefs(matches, manifestPatch) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifestPatch.routes[match.route.id];
    let hrefs = [route.module];
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function getCurrentPageModulePreloadHrefs(matches, manifest) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifest.routes[match.route.id];
    let hrefs = [route.module];
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function dedupe(descriptors, preloads) {
  let set = /* @__PURE__ */ new Set();
  let preloadsSet = new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let alreadyModulePreload = !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
    if (alreadyModulePreload) {
      return deduped;
    }
    let str = JSON.stringify(descriptor);
    if (!set.has(str)) {
      set.add(str);
      deduped.push(descriptor);
    }
    return deduped;
  }, []);
}
function parsePathPatch(href) {
  let path = (0,history__WEBPACK_IMPORTED_MODULE_1__.parsePath)(href);
  if (path.search === void 0)
    path.search = "";
  return path;
}



/***/ }),

/***/ "./node_modules/@remix-run/react/esm/markup.js":
/*!*****************************************************!*\
  !*** ./node_modules/@remix-run/react/esm/markup.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createHtml": () => (/* binding */ createHtml)
/* harmony export */ });
/**
 * @remix-run/react v1.2.0-pre.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function createHtml(html) {
  return {
    __html: html
  };
}



/***/ }),

/***/ "./node_modules/@remix-run/react/esm/routeMatching.js":
/*!************************************************************!*\
  !*** ./node_modules/@remix-run/react/esm/routeMatching.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "matchClientRoutes": () => (/* binding */ matchClientRoutes)
/* harmony export */ });
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/index.js");
/**
 * @remix-run/react v1.2.0-pre.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */

function matchClientRoutes(routes, location) {
  let matches = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_0__.matchRoutes)(routes, location);
  if (!matches)
    return null;
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}



/***/ }),

/***/ "./node_modules/@remix-run/react/esm/routeModules.js":
/*!***********************************************************!*\
  !*** ./node_modules/@remix-run/react/esm/routeModules.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadRouteModule": () => (/* binding */ loadRouteModule)
/* harmony export */ });
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
/**
 * @remix-run/react v1.2.0-pre.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function loadRouteModule(route, routeModulesCache) {
  return __async(this, null, function* () {
    if (route.id in routeModulesCache) {
      return routeModulesCache[route.id];
    }
    try {
      let routeModule = yield __webpack_require__("./node_modules/@remix-run/react/esm lazy recursive")(route.module);
      routeModulesCache[route.id] = routeModule;
      return routeModule;
    } catch (error) {
      window.location.reload();
      return new Promise(() => {
      });
    }
  });
}



/***/ }),

/***/ "./node_modules/@remix-run/react/esm/routes.js":
/*!*****************************************************!*\
  !*** ./node_modules/@remix-run/react/esm/routes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createClientRoute": () => (/* binding */ createClientRoute),
/* harmony export */   "createClientRoutes": () => (/* binding */ createClientRoutes)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _routeModules_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./routeModules.js */ "./node_modules/@remix-run/react/esm/routeModules.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ "./node_modules/@remix-run/react/esm/data.js");
/* harmony import */ var _transition_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transition.js */ "./node_modules/@remix-run/react/esm/transition.js");
/* harmony import */ var _links_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./links.js */ "./node_modules/@remix-run/react/esm/links.js");
/* harmony import */ var _invariant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./invariant.js */ "./node_modules/@remix-run/react/esm/invariant.js");
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
/**
 * @remix-run/react v1.2.0-pre.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */






function createClientRoute(entryRoute, routeModulesCache, Component) {
  return {
    caseSensitive: !!entryRoute.caseSensitive,
    element: /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {
      id: entryRoute.id
    }),
    id: entryRoute.id,
    path: entryRoute.path,
    index: entryRoute.index,
    module: entryRoute.module,
    loader: createLoader(entryRoute, routeModulesCache),
    action: createAction(entryRoute),
    shouldReload: createShouldReload(entryRoute, routeModulesCache),
    ErrorBoundary: entryRoute.hasErrorBoundary,
    CatchBoundary: entryRoute.hasCatchBoundary,
    hasLoader: entryRoute.hasLoader
  };
}
function createClientRoutes(routeManifest, routeModulesCache, Component, parentId) {
  return Object.keys(routeManifest).filter((key) => routeManifest[key].parentId === parentId).map((key) => {
    let route = createClientRoute(routeManifest[key], routeModulesCache, Component);
    let children = createClientRoutes(routeManifest, routeModulesCache, Component, route.id);
    if (children.length > 0)
      route.children = children;
    return route;
  });
}
function createShouldReload(route, routeModules) {
  let shouldReload = (arg) => {
    let module = routeModules[route.id];
    (0,_invariant_js__WEBPACK_IMPORTED_MODULE_1__["default"])(module, `Expected route module to be loaded for ${route.id}`);
    if (module.unstable_shouldReload) {
      return module.unstable_shouldReload(arg);
    }
    return true;
  };
  return shouldReload;
}
function loadRouteModuleWithBlockingLinks(route, routeModules) {
  return __async(this, null, function* () {
    let routeModule = yield (0,_routeModules_js__WEBPACK_IMPORTED_MODULE_2__.loadRouteModule)(route, routeModules);
    yield (0,_links_js__WEBPACK_IMPORTED_MODULE_3__.prefetchStyleLinks)(routeModule);
    return routeModule;
  });
}
function createLoader(route, routeModules) {
  let loader = (_0) => __async(this, [_0], function* ({
    url,
    signal,
    submission
  }) {
    if (route.hasLoader) {
      let [result] = yield Promise.all([(0,_data_js__WEBPACK_IMPORTED_MODULE_4__.fetchData)(url, route.id, signal, submission), loadRouteModuleWithBlockingLinks(route, routeModules)]);
      if (result instanceof Error)
        throw result;
      let redirect = yield checkRedirect(result);
      if (redirect)
        return redirect;
      if ((0,_data_js__WEBPACK_IMPORTED_MODULE_4__.isCatchResponse)(result)) {
        throw new _transition_js__WEBPACK_IMPORTED_MODULE_5__.CatchValue(result.status, result.statusText, yield (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.extractData)(result.clone()));
      }
      return (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.extractData)(result);
    } else {
      yield loadRouteModuleWithBlockingLinks(route, routeModules);
    }
  });
  return loader;
}
function createAction(route) {
  if (!route.hasAction)
    return void 0;
  let action = (_0) => __async(this, [_0], function* ({
    url,
    signal,
    submission
  }) {
    let result = yield (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.fetchData)(url, route.id, signal, submission);
    if (result instanceof Error) {
      throw result;
    }
    let redirect = yield checkRedirect(result);
    if (redirect)
      return redirect;
    if ((0,_data_js__WEBPACK_IMPORTED_MODULE_4__.isCatchResponse)(result)) {
      throw new _transition_js__WEBPACK_IMPORTED_MODULE_5__.CatchValue(result.status, result.statusText, yield (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.extractData)(result.clone()));
    }
    return (0,_data_js__WEBPACK_IMPORTED_MODULE_4__.extractData)(result);
  });
  return action;
}
function checkRedirect(response) {
  return __async(this, null, function* () {
    if ((0,_data_js__WEBPACK_IMPORTED_MODULE_4__.isRedirectResponse)(response)) {
      let url = new URL(response.headers.get("X-Remix-Redirect"), window.location.origin);
      if (url.origin !== window.location.origin) {
        yield new Promise(() => {
          window.location.replace(url.href);
        });
      } else {
        return new _transition_js__WEBPACK_IMPORTED_MODULE_5__.TransitionRedirect(url.pathname + url.search);
      }
    }
    return null;
  });
}



/***/ }),

/***/ "./node_modules/@remix-run/react/esm/scroll-restoration.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@remix-run/react/esm/scroll-restoration.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScrollRestoration": () => (/* binding */ ScrollRestoration)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/index.js");
/* harmony import */ var _components_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components.js */ "./node_modules/@remix-run/react/esm/components.js");
/**
 * @remix-run/react v1.2.0-pre.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */



let STORAGE_KEY = "positions";
let positions = {};
if (typeof document !== "undefined") {
  let sessionPositions = sessionStorage.getItem(STORAGE_KEY);
  if (sessionPositions) {
    positions = JSON.parse(sessionPositions);
  }
}
function ScrollRestoration() {
  useScrollRestoration();
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    window.history.scrollRestoration = "manual";
  }, []);
  (0,_components_js__WEBPACK_IMPORTED_MODULE_1__.useBeforeUnload)(react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    window.history.scrollRestoration = "auto";
  }, []));
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
          let STORAGE_KEY = ${JSON.stringify(STORAGE_KEY)};
          if (!window.history.state || !window.history.state.key) {
            window.history.replaceState({ key: Math.random().toString(32).slice(2) }, null);
          }
          try {
            let positions = JSON.parse(sessionStorage.getItem(STORAGE_KEY) || '{}')
            let storedY = positions[window.history.state.key];
            if (typeof storedY === 'number') {
              window.scrollTo(0, storedY)
            }
          } catch(error) {
            console.error(error)
            sessionStorage.removeItem(STORAGE_KEY)
          }
        `
    }
  });
}
let hydrated = false;
function useScrollRestoration() {
  let location = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_2__.useLocation)();
  let transition = (0,_components_js__WEBPACK_IMPORTED_MODULE_1__.useTransition)();
  let wasSubmissionRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (transition.submission) {
      wasSubmissionRef.current = true;
    }
  }, [transition]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (transition.location) {
      positions[location.key] = window.scrollY;
    }
  }, [transition, location]);
  (0,_components_js__WEBPACK_IMPORTED_MODULE_1__.useBeforeUnload)(react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
  }, []));
  if (typeof document !== "undefined") {
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      if (!hydrated) {
        hydrated = true;
        return;
      }
      let y = positions[location.key];
      if (y) {
        window.scrollTo(0, y);
        return;
      }
      if (location.hash) {
        let el = document.getElementById(location.hash.slice(1));
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      if (wasSubmissionRef.current === true) {
        wasSubmissionRef.current = false;
        return;
      }
      window.scrollTo(0, 0);
    }, [location]);
  }
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (transition.submission) {
      wasSubmissionRef.current = true;
    }
  }, [transition]);
}



/***/ }),

/***/ "./node_modules/@remix-run/react/esm/server.js":
/*!*****************************************************!*\
  !*** ./node_modules/@remix-run/react/esm/server.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RemixServer": () => (/* binding */ RemixServer)
/* harmony export */ });
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! history */ "./node_modules/history/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components.js */ "./node_modules/@remix-run/react/esm/components.js");
/**
 * @remix-run/react v1.2.0-pre.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */



function RemixServer({
  context,
  url
}) {
  if (typeof url === "string") {
    url = new URL(url);
  }
  let location = {
    pathname: url.pathname,
    search: url.search,
    hash: "",
    state: null,
    key: "default"
  };
  let staticNavigator = {
    createHref(to) {
      return typeof to === "string" ? to : (0,history__WEBPACK_IMPORTED_MODULE_1__.createPath)(to);
    },
    push(to) {
      throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
    },
    replace(to) {
      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`);
    },
    go(delta) {
      throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`);
    },
    back() {
      throw new Error(`You cannot use navigator.back() on the server because it is a stateless environment.`);
    },
    forward() {
      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless environment.`);
    },
    block() {
      throw new Error(`You cannot use navigator.block() on the server because it is a stateless environment.`);
    }
  };
  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_components_js__WEBPACK_IMPORTED_MODULE_2__.RemixEntry, {
    context,
    action: history__WEBPACK_IMPORTED_MODULE_1__.Action.Pop,
    location,
    navigator: staticNavigator,
    static: true
  });
}



/***/ }),

/***/ "./node_modules/@remix-run/react/esm/transition.js":
/*!*********************************************************!*\
  !*** ./node_modules/@remix-run/react/esm/transition.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CatchValue": () => (/* binding */ CatchValue),
/* harmony export */   "IDLE_FETCHER": () => (/* binding */ IDLE_FETCHER),
/* harmony export */   "IDLE_TRANSITION": () => (/* binding */ IDLE_TRANSITION),
/* harmony export */   "TransitionRedirect": () => (/* binding */ TransitionRedirect),
/* harmony export */   "createTransitionManager": () => (/* binding */ createTransitionManager)
/* harmony export */ });
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! history */ "./node_modules/history/index.js");
/* harmony import */ var _routeMatching_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./routeMatching.js */ "./node_modules/@remix-run/react/esm/routeMatching.js");
/* harmony import */ var _invariant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./invariant.js */ "./node_modules/@remix-run/react/esm/invariant.js");
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
/**
 * @remix-run/react v1.2.0-pre.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */



class CatchValue {
  constructor(status, statusText, data) {
    this.status = status;
    this.statusText = statusText;
    this.data = data;
  }
}
function isActionSubmission(submission) {
  return ["POST", "PUT", "PATCH", "DELETE"].includes(submission.method);
}
function isLoaderSubmission(submission) {
  return submission.method === "GET";
}
function isRedirectLocation(location) {
  return Boolean(location.state) && location.state.isRedirect;
}
function isLoaderRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "loader";
}
function isActionRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "action";
}
function isFetchActionRedirect(location) {
  return isRedirectLocation(location) && location.state.type === "fetchAction";
}
function isLoaderSubmissionRedirectLocation(location) {
  return isRedirectLocation(location) && location.state.type === "loaderSubmission";
}
class TransitionRedirect {
  constructor(location) {
    this.location = typeof location === "string" ? location : location.pathname + location.search;
  }
}
const IDLE_TRANSITION = {
  state: "idle",
  submission: void 0,
  location: void 0,
  type: "idle"
};
const IDLE_FETCHER = {
  state: "idle",
  type: "init",
  data: void 0,
  submission: void 0
};
function createTransitionManager(init) {
  let {
    routes
  } = init;
  let pendingNavigationController;
  let fetchControllers = /* @__PURE__ */ new Map();
  let incrementingLoadId = 0;
  let navigationLoadId = -1;
  let fetchReloadIds = /* @__PURE__ */ new Map();
  let matches = (0,_routeMatching_js__WEBPACK_IMPORTED_MODULE_0__.matchClientRoutes)(routes, init.location);
  if (!matches) {
    matches = [{
      params: {},
      pathname: "",
      route: routes[0]
    }];
  }
  let state = {
    location: init.location,
    loaderData: init.loaderData || {},
    actionData: init.actionData,
    catch: init.catch,
    error: init.error,
    catchBoundaryId: init.catchBoundaryId || null,
    errorBoundaryId: init.errorBoundaryId || null,
    matches,
    nextMatches: void 0,
    transition: IDLE_TRANSITION,
    fetchers: /* @__PURE__ */ new Map()
  };
  function update(updates) {
    state = Object.assign({}, state, updates);
    init.onChange(state);
  }
  function getState() {
    return state;
  }
  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    if (fetchControllers.has(key))
      abortFetcher(key);
    fetchReloadIds.delete(key);
    state.fetchers.delete(key);
  }
  function send(event) {
    return __async(this, null, function* () {
      switch (event.type) {
        case "navigation": {
          let {
            action,
            location,
            submission
          } = event;
          let matches2 = (0,_routeMatching_js__WEBPACK_IMPORTED_MODULE_0__.matchClientRoutes)(routes, location);
          if (!matches2) {
            matches2 = [{
              params: {},
              pathname: "",
              route: routes[0]
            }];
            yield handleNotFoundNavigation(location, matches2);
          } else if (!submission && isHashChangeOnly(location)) {
            yield handleHashChange(location, matches2);
          } else if (action === history__WEBPACK_IMPORTED_MODULE_1__.Action.Pop) {
            yield handleLoad(location, matches2);
          } else if (submission && isActionSubmission(submission)) {
            yield handleActionSubmissionNavigation(location, submission, matches2);
          } else if (submission && isLoaderSubmission(submission)) {
            yield handleLoaderSubmissionNavigation(location, submission, matches2);
          } else if (isActionRedirectLocation(location)) {
            yield handleActionRedirect(location, matches2);
          } else if (isLoaderSubmissionRedirectLocation(location)) {
            yield handleLoaderSubmissionRedirect(location, matches2);
          } else if (isLoaderRedirectLocation(location)) {
            yield handleLoaderRedirect(location, matches2);
          } else if (isFetchActionRedirect(location)) {
            yield handleFetchActionRedirect(location, matches2);
          } else {
            yield handleLoad(location, matches2);
          }
          navigationLoadId = -1;
          break;
        }
        case "fetcher": {
          let {
            key,
            submission,
            href
          } = event;
          let matches2 = (0,_routeMatching_js__WEBPACK_IMPORTED_MODULE_0__.matchClientRoutes)(routes, href);
          (0,_invariant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(matches2, "No matches found");
          let match = matches2.slice(-1)[0];
          if (fetchControllers.has(key))
            abortFetcher(key);
          if (submission && isActionSubmission(submission)) {
            yield handleActionFetchSubmission(key, submission, match);
          } else if (submission && isLoaderSubmission(submission)) {
            yield handleLoaderFetchSubmission(href, key, submission, match);
          } else {
            yield handleLoaderFetch(href, key, match);
          }
          break;
        }
        default: {
          throw new Error(`Unknown data event type: ${event.type}`);
        }
      }
    });
  }
  function dispose() {
    abortNormalNavigation();
    for (let [, controller] of fetchControllers) {
      controller.abort();
    }
  }
  function handleActionFetchSubmission(key, submission, match) {
    return __async(this, null, function* () {
      let currentFetcher = state.fetchers.get(key);
      let fetcher = {
        state: "submitting",
        type: "actionSubmission",
        submission,
        data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
      };
      state.fetchers.set(key, fetcher);
      update({
        fetchers: new Map(state.fetchers)
      });
      let controller = new AbortController();
      fetchControllers.set(key, controller);
      let result = yield callAction(submission, match, controller.signal);
      if (controller.signal.aborted) {
        return;
      }
      if (isRedirectResult(result)) {
        let locationState = {
          isRedirect: true,
          type: "fetchAction"
        };
        init.onRedirect(result.value.location, locationState);
        let doneFetcher2 = {
          state: "idle",
          type: "done",
          data: result.value,
          submission: void 0
        };
        state.fetchers.set(key, doneFetcher2);
        update({
          fetchers: new Map(state.fetchers)
        });
        return;
      }
      if (maybeBailOnError(match, key, result)) {
        return;
      }
      if (yield maybeBailOnCatch(match, key, result)) {
        return;
      }
      let loadFetcher = {
        state: "loading",
        type: "actionReload",
        data: result.value,
        submission
      };
      state.fetchers.set(key, loadFetcher);
      update({
        fetchers: new Map(state.fetchers)
      });
      let maybeActionErrorResult = isErrorResult(result) ? result : void 0;
      let maybeActionCatchResult = isCatchResult(result) ? result : void 0;
      let loadId = ++incrementingLoadId;
      fetchReloadIds.set(key, loadId);
      let matchesToLoad = state.nextMatches || state.matches;
      let hrefToLoad = createHref(state.transition.location || state.location);
      let results = yield callLoaders(state, createUrl(hrefToLoad), matchesToLoad, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, match.route.id, loadFetcher);
      if (controller.signal.aborted) {
        return;
      }
      fetchReloadIds.delete(key);
      fetchControllers.delete(key);
      let redirect = findRedirect(results);
      if (redirect) {
        let locationState = {
          isRedirect: true,
          type: "loader"
        };
        init.onRedirect(redirect.location, locationState);
        return;
      }
      let [error, errorBoundaryId] = findErrorAndBoundaryId(results, state.matches, maybeActionErrorResult);
      let [catchVal, catchBoundaryId] = yield findCatchAndBoundaryId(results, state.matches, maybeActionCatchResult);
      let doneFetcher = {
        state: "idle",
        type: "done",
        data: result.value,
        submission: void 0
      };
      state.fetchers.set(key, doneFetcher);
      let abortedKeys = abortStaleFetchLoads(loadId);
      if (abortedKeys) {
        markFetchersDone(abortedKeys);
      }
      let yeetedNavigation = yeetStaleNavigationLoad(loadId);
      if (yeetedNavigation) {
        let {
          transition
        } = state;
        (0,_invariant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(transition.state === "loading", "Expected loading transition");
        update({
          location: transition.location,
          matches: state.nextMatches,
          error,
          errorBoundaryId,
          catch: catchVal,
          catchBoundaryId,
          loaderData: makeLoaderData(state, results, matchesToLoad),
          actionData: transition.type === "actionReload" ? state.actionData : void 0,
          transition: IDLE_TRANSITION,
          fetchers: new Map(state.fetchers)
        });
      } else {
        update({
          fetchers: new Map(state.fetchers),
          error,
          errorBoundaryId,
          loaderData: makeLoaderData(state, results, matchesToLoad)
        });
      }
    });
  }
  function yeetStaleNavigationLoad(landedId) {
    let isLoadingNavigation = state.transition.state === "loading";
    if (isLoadingNavigation && navigationLoadId < landedId) {
      abortNormalNavigation();
      return true;
    }
    return false;
  }
  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key);
      let doneFetcher = {
        state: "idle",
        type: "done",
        data: fetcher.data,
        submission: void 0
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        (0,_invariant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fetcher, `Expected fetcher: ${key}`);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    return yeetedKeys.length ? yeetedKeys : false;
  }
  function handleLoaderFetchSubmission(href, key, submission, match) {
    return __async(this, null, function* () {
      let currentFetcher = state.fetchers.get(key);
      let fetcher = {
        state: "submitting",
        type: "loaderSubmission",
        submission,
        data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
      };
      state.fetchers.set(key, fetcher);
      update({
        fetchers: new Map(state.fetchers)
      });
      let controller = new AbortController();
      fetchControllers.set(key, controller);
      let result = yield callLoader(match, createUrl(href), controller.signal);
      fetchControllers.delete(key);
      if (controller.signal.aborted) {
        return;
      }
      if (isRedirectResult(result)) {
        let locationState = {
          isRedirect: true,
          type: "loader"
        };
        init.onRedirect(result.value.location, locationState);
        return;
      }
      if (maybeBailOnError(match, key, result)) {
        return;
      }
      if (yield maybeBailOnCatch(match, key, result)) {
        return;
      }
      let doneFetcher = {
        state: "idle",
        type: "done",
        data: result.value,
        submission: void 0
      };
      state.fetchers.set(key, doneFetcher);
      update({
        fetchers: new Map(state.fetchers)
      });
    });
  }
  function handleLoaderFetch(href, key, match) {
    return __async(this, null, function* () {
      if (typeof AbortController === "undefined") {
        throw new Error("handleLoaderFetch was called during the server render, but it shouldn't be. You are likely calling useFetcher.load() in the body of your component. Try moving it to a useEffect or a callback.");
      }
      let currentFetcher = state.fetchers.get(key);
      let fetcher = {
        state: "loading",
        type: "normalLoad",
        submission: void 0,
        data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
      };
      state.fetchers.set(key, fetcher);
      update({
        fetchers: new Map(state.fetchers)
      });
      let controller = new AbortController();
      fetchControllers.set(key, controller);
      let result = yield callLoader(match, createUrl(href), controller.signal);
      if (controller.signal.aborted)
        return;
      fetchControllers.delete(key);
      if (isRedirectResult(result)) {
        let locationState = {
          isRedirect: true,
          type: "loader"
        };
        init.onRedirect(result.value.location, locationState);
        return;
      }
      if (maybeBailOnError(match, key, result)) {
        return;
      }
      if (yield maybeBailOnCatch(match, key, result)) {
        return;
      }
      let doneFetcher = {
        state: "idle",
        type: "done",
        data: result.value,
        submission: void 0
      };
      state.fetchers.set(key, doneFetcher);
      update({
        fetchers: new Map(state.fetchers)
      });
    });
  }
  function maybeBailOnCatch(match, key, result) {
    return __async(this, null, function* () {
      if (isCatchResult(result)) {
        let catchBoundaryId = findNearestCatchBoundary(match, state.matches);
        state.fetchers.delete(key);
        update({
          transition: IDLE_TRANSITION,
          fetchers: new Map(state.fetchers),
          catch: {
            data: result.value.data,
            status: result.value.status,
            statusText: result.value.statusText
          },
          catchBoundaryId
        });
        return true;
      }
      return false;
    });
  }
  function maybeBailOnError(match, key, result) {
    if (isErrorResult(result)) {
      let errorBoundaryId = findNearestBoundary(match, state.matches);
      state.fetchers.delete(key);
      update({
        fetchers: new Map(state.fetchers),
        error: result.value,
        errorBoundaryId
      });
      return true;
    }
    return false;
  }
  function handleNotFoundNavigation(location, matches2) {
    return __async(this, null, function* () {
      abortNormalNavigation();
      let transition = {
        state: "loading",
        type: "normalLoad",
        submission: void 0,
        location
      };
      update({
        transition,
        nextMatches: matches2
      });
      yield Promise.resolve();
      let catchBoundaryId = findNearestCatchBoundary(matches2[0], matches2);
      update({
        location,
        matches: matches2,
        catch: {
          data: null,
          status: 404,
          statusText: "Not Found"
        },
        catchBoundaryId,
        transition: IDLE_TRANSITION
      });
    });
  }
  function handleActionSubmissionNavigation(location, submission, matches2) {
    return __async(this, null, function* () {
      abortNormalNavigation();
      let transition = {
        state: "submitting",
        type: "actionSubmission",
        submission,
        location
      };
      update({
        transition,
        nextMatches: matches2
      });
      let controller = new AbortController();
      pendingNavigationController = controller;
      if (!isIndexRequestAction(submission.action) && matches2[matches2.length - 1].route.id.endsWith("/index")) {
        matches2 = matches2.slice(0, -1);
      }
      let leafMatch = matches2.slice(-1)[0];
      let result = yield callAction(submission, leafMatch, controller.signal);
      if (controller.signal.aborted) {
        return;
      }
      if (isRedirectResult(result)) {
        let locationState = {
          isRedirect: true,
          type: "action"
        };
        init.onRedirect(result.value.location, locationState);
        return;
      }
      if (isCatchResult(result)) {
        let [catchVal, catchBoundaryId] = yield findCatchAndBoundaryId([result], matches2, result);
        update({
          transition: IDLE_TRANSITION,
          catch: catchVal,
          catchBoundaryId
        });
        return;
      }
      let loadTransition = {
        state: "loading",
        type: "actionReload",
        submission,
        location
      };
      update({
        transition: loadTransition,
        actionData: {
          [leafMatch.route.id]: result.value
        }
      });
      yield loadPageData(location, matches2, submission, leafMatch.route.id, result);
    });
  }
  function handleLoaderSubmissionNavigation(location, submission, matches2) {
    return __async(this, null, function* () {
      abortNormalNavigation();
      let transition = {
        state: "submitting",
        type: "loaderSubmission",
        submission,
        location
      };
      update({
        transition,
        nextMatches: matches2
      });
      yield loadPageData(location, matches2, submission);
    });
  }
  function handleHashChange(location, matches2) {
    return __async(this, null, function* () {
      abortNormalNavigation();
      let transition = {
        state: "loading",
        type: "normalLoad",
        submission: void 0,
        location
      };
      update({
        transition,
        nextMatches: matches2
      });
      yield Promise.resolve();
      update({
        location,
        matches: matches2,
        transition: IDLE_TRANSITION
      });
    });
  }
  function handleLoad(location, matches2) {
    return __async(this, null, function* () {
      abortNormalNavigation();
      let transition = {
        state: "loading",
        type: "normalLoad",
        submission: void 0,
        location
      };
      update({
        transition,
        nextMatches: matches2
      });
      yield loadPageData(location, matches2);
    });
  }
  function handleLoaderRedirect(location, matches2) {
    return __async(this, null, function* () {
      abortNormalNavigation();
      let transition = {
        state: "loading",
        type: "normalRedirect",
        submission: void 0,
        location
      };
      update({
        transition,
        nextMatches: matches2
      });
      yield loadPageData(location, matches2);
    });
  }
  function handleLoaderSubmissionRedirect(location, matches2) {
    return __async(this, null, function* () {
      abortNormalNavigation();
      (0,_invariant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.transition.type === "loaderSubmission", `Unexpected transition: ${JSON.stringify(state.transition)}`);
      let {
        submission
      } = state.transition;
      let transition = {
        state: "loading",
        type: "loaderSubmissionRedirect",
        submission,
        location
      };
      update({
        transition,
        nextMatches: matches2
      });
      yield loadPageData(location, matches2, submission);
    });
  }
  function handleFetchActionRedirect(location, matches2) {
    return __async(this, null, function* () {
      abortNormalNavigation();
      let transition = {
        state: "loading",
        type: "fetchActionRedirect",
        submission: void 0,
        location
      };
      update({
        transition,
        nextMatches: matches2
      });
      yield loadPageData(location, matches2);
    });
  }
  function handleActionRedirect(location, matches2) {
    return __async(this, null, function* () {
      abortNormalNavigation();
      (0,_invariant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.transition.type === "actionSubmission" || state.transition.type === "actionReload", `Unexpected transition: ${JSON.stringify(state.transition)}`);
      let {
        submission
      } = state.transition;
      let transition = {
        state: "loading",
        type: "actionRedirect",
        submission,
        location
      };
      update({
        transition,
        nextMatches: matches2
      });
      yield loadPageData(location, matches2, submission);
    });
  }
  function isHashChangeOnly(location) {
    return createHref(state.location) === createHref(location) && state.location.hash !== location.hash;
  }
  function loadPageData(location, matches2, submission, submissionRouteId, actionResult) {
    return __async(this, null, function* () {
      let maybeActionErrorResult = actionResult && isErrorResult(actionResult) ? actionResult : void 0;
      let maybeActionCatchResult = actionResult && isCatchResult(actionResult) ? actionResult : void 0;
      let controller = new AbortController();
      pendingNavigationController = controller;
      navigationLoadId = ++incrementingLoadId;
      let results = yield callLoaders(state, createUrl(createHref(location)), matches2, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, submissionRouteId);
      if (controller.signal.aborted) {
        return;
      }
      let redirect = findRedirect(results);
      if (redirect) {
        if (state.transition.type === "actionReload") {
          let locationState = {
            isRedirect: true,
            type: "action"
          };
          init.onRedirect(redirect.location, locationState);
        } else if (state.transition.type === "loaderSubmission") {
          let locationState = {
            isRedirect: true,
            type: "loaderSubmission"
          };
          init.onRedirect(redirect.location, locationState);
        } else {
          let locationState = {
            isRedirect: true,
            type: "loader"
          };
          init.onRedirect(redirect.location, locationState);
        }
        return;
      }
      let [error, errorBoundaryId] = findErrorAndBoundaryId(results, matches2, maybeActionErrorResult);
      let [catchVal, catchBoundaryId] = yield findCatchAndBoundaryId(results, matches2, maybeActionErrorResult);
      let abortedIds = abortStaleFetchLoads(navigationLoadId);
      if (abortedIds) {
        markFetchersDone(abortedIds);
      }
      update({
        location,
        matches: matches2,
        error,
        errorBoundaryId,
        catch: catchVal,
        catchBoundaryId,
        loaderData: makeLoaderData(state, results, matches2),
        actionData: state.transition.type === "actionReload" ? state.actionData : void 0,
        transition: IDLE_TRANSITION,
        fetchers: abortedIds ? new Map(state.fetchers) : state.fetchers
      });
    });
  }
  function abortNormalNavigation() {
    var _pendingNavigationCon;
    (_pendingNavigationCon = pendingNavigationController) === null || _pendingNavigationCon === void 0 ? void 0 : _pendingNavigationCon.abort();
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    (0,_invariant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(controller, `Expected fetch controller: ${key}`);
    controller.abort();
    fetchControllers.delete(key);
  }
  return {
    send,
    getState,
    getFetcher,
    deleteFetcher,
    dispose,
    get _internalFetchControllers() {
      return fetchControllers;
    }
  };
}
function isIndexRequestAction(action) {
  let indexRequest = false;
  let searchParams = new URLSearchParams(action.split("?", 2)[1] || "");
  for (let param of searchParams.getAll("index")) {
    if (!param) {
      indexRequest = true;
    }
  }
  return indexRequest;
}
function callLoaders(state, url, matches, signal, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher) {
  return __async(this, null, function* () {
    let matchesToLoad = filterMatchesToLoad(state, url, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher);
    return Promise.all(matchesToLoad.map((match) => callLoader(match, url, signal)));
  });
}
function callLoader(match, url, signal) {
  return __async(this, null, function* () {
    (0,_invariant_js__WEBPACK_IMPORTED_MODULE_2__["default"])(match.route.loader, `Expected loader for ${match.route.id}`);
    try {
      let {
        params
      } = match;
      let value = yield match.route.loader({
        params,
        url,
        signal
      });
      return {
        match,
        value
      };
    } catch (error) {
      return {
        match,
        value: error
      };
    }
  });
}
function callAction(submission, match, signal) {
  return __async(this, null, function* () {
    if (!match.route.action) {
      throw new Error(`Route "${match.route.id}" does not have an action, but you are trying to submit to it. To fix this, please add an \`action\` function to the route`);
    }
    try {
      let value = yield match.route.action({
        url: createUrl(submission.action),
        params: match.params,
        submission,
        signal
      });
      return {
        match,
        value
      };
    } catch (error) {
      return {
        match,
        value: error
      };
    }
  });
}
function filterMatchesToLoad(state, url, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher) {
  if (submissionRouteId && (actionCatchResult || actionErrorResult)) {
    let foundProblematicRoute = false;
    matches = matches.filter((match) => {
      if (foundProblematicRoute) {
        return false;
      }
      if (match.route.id === submissionRouteId) {
        foundProblematicRoute = true;
        return false;
      }
      return true;
    });
  }
  let isNew = (match, index) => {
    if (!state.matches[index])
      return true;
    return match.route.id !== state.matches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    var _state$matches$index$;
    return state.matches[index].pathname !== match.pathname || ((_state$matches$index$ = state.matches[index].route.path) === null || _state$matches$index$ === void 0 ? void 0 : _state$matches$index$.endsWith("*")) && state.matches[index].params["*"] !== match.params["*"];
  };
  let filterByRouteProps = (match, index) => {
    if (!match.route.loader) {
      return false;
    }
    if (isNew(match, index) || matchPathChanged(match, index)) {
      return true;
    }
    if (match.route.shouldReload) {
      let prevUrl = createUrl(createHref(state.location));
      return match.route.shouldReload({
        prevUrl,
        url,
        submission,
        params: match.params
      });
    }
    return true;
  };
  let isInRootCatchBoundary = state.matches.length === 1;
  if (isInRootCatchBoundary) {
    return matches.filter((match) => !!match.route.loader);
  }
  if ((fetcher === null || fetcher === void 0 ? void 0 : fetcher.type) === "actionReload") {
    return matches.filter(filterByRouteProps);
  } else if (state.transition.type === "actionReload" || state.transition.type === "actionRedirect" || createHref(url) === createHref(state.location) || url.searchParams.toString() !== state.location.search) {
    return matches.filter(filterByRouteProps);
  }
  return matches.filter((match, index, arr) => {
    if ((actionErrorResult || actionCatchResult) && arr.length - 1 === index) {
      return false;
    }
    return match.route.loader && (isNew(match, index) || matchPathChanged(match, index));
  });
}
function isRedirectResult(result) {
  return result.value instanceof TransitionRedirect;
}
function createHref(location) {
  return location.pathname + location.search;
}
function findRedirect(results) {
  for (let result of results) {
    if (isRedirectResult(result)) {
      return result.value;
    }
  }
  return null;
}
function findCatchAndBoundaryId(results, matches, actionCatchResult) {
  return __async(this, null, function* () {
    let loaderCatchResult;
    for (let result of results) {
      if (isCatchResult(result)) {
        loaderCatchResult = result;
        break;
      }
    }
    let extractCatchData = (res) => __async(this, null, function* () {
      return {
        status: res.status,
        statusText: res.statusText,
        data: res.data
      };
    });
    if (actionCatchResult && loaderCatchResult) {
      let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
      return [yield extractCatchData(actionCatchResult.value), boundaryId];
    }
    if (loaderCatchResult) {
      let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
      return [yield extractCatchData(loaderCatchResult.value), boundaryId];
    }
    return [void 0, void 0];
  });
}
function findErrorAndBoundaryId(results, matches, actionErrorResult) {
  let loaderErrorResult;
  for (let result of results) {
    if (isErrorResult(result)) {
      loaderErrorResult = result;
      break;
    }
  }
  if (actionErrorResult && loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (actionErrorResult) {
    let boundaryId = findNearestBoundary(actionErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [loaderErrorResult.value, boundaryId];
  }
  return [void 0, void 0];
}
function findNearestCatchBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches) {
    if (match.route.CatchBoundary) {
      nearestBoundaryId = match.route.id;
    }
    if (match === matchWithError) {
      break;
    }
  }
  return nearestBoundaryId;
}
function findNearestBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches) {
    if (match.route.ErrorBoundary) {
      nearestBoundaryId = match.route.id;
    }
    if (match === matchWithError) {
      break;
    }
  }
  return nearestBoundaryId;
}
function makeLoaderData(state, results, matches) {
  let newData = {};
  for (let {
    match,
    value
  } of results) {
    newData[match.route.id] = value;
  }
  let loaderData = {};
  for (let {
    route
  } of matches) {
    let value = newData[route.id] !== void 0 ? newData[route.id] : state.loaderData[route.id];
    if (value !== void 0) {
      loaderData[route.id] = value;
    }
  }
  return loaderData;
}
function isCatchResult(result) {
  return result.value instanceof CatchValue;
}
function isErrorResult(result) {
  return result.value instanceof Error;
}
function createUrl(href) {
  return new URL(href, window.location.origin);
}



/***/ }),

/***/ "./node_modules/history/index.js":
/*!***************************************!*\
  !*** ./node_modules/history/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Action": () => (/* binding */ r),
/* harmony export */   "createBrowserHistory": () => (/* binding */ createBrowserHistory),
/* harmony export */   "createHashHistory": () => (/* binding */ createHashHistory),
/* harmony export */   "createMemoryHistory": () => (/* binding */ createMemoryHistory),
/* harmony export */   "createPath": () => (/* binding */ I),
/* harmony export */   "parsePath": () => (/* binding */ J)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");

var r, B = r || (r = {});
B.Pop = "POP";
B.Push = "PUSH";
B.Replace = "REPLACE";
var C =  true ? function(b) {
  return Object.freeze(b);
} : 0;
function D(b, h) {
  if (!b) {
    typeof console !== "undefined" && console.warn(h);
    try {
      throw Error(h);
    } catch (e) {
    }
  }
}
function E(b) {
  b.preventDefault();
  b.returnValue = "";
}
function F() {
  var b = [];
  return { get length() {
    return b.length;
  }, push: function(h) {
    b.push(h);
    return function() {
      b = b.filter(function(e) {
        return e !== h;
      });
    };
  }, call: function(h) {
    b.forEach(function(e) {
      return e && e(h);
    });
  } };
}
function H() {
  return Math.random().toString(36).substr(2, 8);
}
function I(b) {
  var h = b.pathname;
  h = h === void 0 ? "/" : h;
  var e = b.search;
  e = e === void 0 ? "" : e;
  b = b.hash;
  b = b === void 0 ? "" : b;
  e && e !== "?" && (h += e.charAt(0) === "?" ? e : "?" + e);
  b && b !== "#" && (h += b.charAt(0) === "#" ? b : "#" + b);
  return h;
}
function J(b) {
  var h = {};
  if (b) {
    var e = b.indexOf("#");
    0 <= e && (h.hash = b.substr(e), b = b.substr(0, e));
    e = b.indexOf("?");
    0 <= e && (h.search = b.substr(e), b = b.substr(0, e));
    b && (h.pathname = b);
  }
  return h;
}
function createBrowserHistory(b) {
  function h() {
    var c = p.location, a = m.state || {};
    return [a.idx, C({ pathname: c.pathname, search: c.search, hash: c.hash, state: a.usr || null, key: a.key || "default" })];
  }
  function e(c) {
    return typeof c === "string" ? c : I(c);
  }
  function x(c, a) {
    a === void 0 && (a = null);
    return C((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({ pathname: q.pathname, hash: "", search: "" }, typeof c === "string" ? J(c) : c, { state: a, key: H() }));
  }
  function z(c) {
    t = c;
    c = h();
    v = c[0];
    q = c[1];
    d.call({ action: t, location: q });
  }
  function A(c, a) {
    function f() {
      A(c, a);
    }
    var l = r.Push, k = x(c, a);
    if (!g.length || (g.call({ action: l, location: k, retry: f }), false)) {
      var n = [{ usr: k.state, key: k.key, idx: v + 1 }, e(k)];
      k = n[0];
      n = n[1];
      try {
        m.pushState(k, "", n);
      } catch (G) {
        p.location.assign(n);
      }
      z(l);
    }
  }
  function y(c, a) {
    function f() {
      y(c, a);
    }
    var l = r.Replace, k = x(c, a);
    g.length && (g.call({ action: l, location: k, retry: f }), 1) || (k = [{ usr: k.state, key: k.key, idx: v }, e(k)], m.replaceState(k[0], "", k[1]), z(l));
  }
  function w(c) {
    m.go(c);
  }
  b === void 0 && (b = {});
  b = b.window;
  var p = b === void 0 ? document.defaultView : b, m = p.history, u = null;
  p.addEventListener("popstate", function() {
    if (u)
      g.call(u), u = null;
    else {
      var c = r.Pop, a = h(), f = a[0];
      a = a[1];
      if (g.length)
        if (f != null) {
          var l = v - f;
          l && (u = { action: c, location: a, retry: function() {
            w(-1 * l);
          } }, w(l));
        } else
           true ? D(false, "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.") : 0;
      else
        z(c);
    }
  });
  var t = r.Pop;
  b = h();
  var v = b[0], q = b[1], d = F(), g = F();
  v == null && (v = 0, m.replaceState((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, m.state, { idx: v }), ""));
  return { get action() {
    return t;
  }, get location() {
    return q;
  }, createHref: e, push: A, replace: y, go: w, back: function() {
    w(-1);
  }, forward: function() {
    w(1);
  }, listen: function(c) {
    return d.push(c);
  }, block: function(c) {
    var a = g.push(c);
    g.length === 1 && p.addEventListener("beforeunload", E);
    return function() {
      a();
      g.length || p.removeEventListener("beforeunload", E);
    };
  } };
}
;
function createHashHistory(b) {
  function h() {
    var a = J(m.location.hash.substr(1)), f = a.pathname, l = a.search;
    a = a.hash;
    var k = u.state || {};
    return [k.idx, C({ pathname: f === void 0 ? "/" : f, search: l === void 0 ? "" : l, hash: a === void 0 ? "" : a, state: k.usr || null, key: k.key || "default" })];
  }
  function e() {
    if (t)
      c.call(t), t = null;
    else {
      var a = r.Pop, f = h(), l = f[0];
      f = f[1];
      if (c.length)
        if (l != null) {
          var k = q - l;
          k && (t = { action: a, location: f, retry: function() {
            p(-1 * k);
          } }, p(k));
        } else
           true ? D(false, "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.") : 0;
      else
        A(a);
    }
  }
  function x(a) {
    var f = document.querySelector("base"), l = "";
    f && f.getAttribute("href") && (f = m.location.href, l = f.indexOf("#"), l = l === -1 ? f : f.slice(0, l));
    return l + "#" + (typeof a === "string" ? a : I(a));
  }
  function z(a, f) {
    f === void 0 && (f = null);
    return C((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({ pathname: d.pathname, hash: "", search: "" }, typeof a === "string" ? J(a) : a, { state: f, key: H() }));
  }
  function A(a) {
    v = a;
    a = h();
    q = a[0];
    d = a[1];
    g.call({ action: v, location: d });
  }
  function y(a, f) {
    function l() {
      y(a, f);
    }
    var k = r.Push, n = z(a, f);
     true ? D(n.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.push(" + JSON.stringify(a) + ")") : 0;
    if (!c.length || (c.call({ action: k, location: n, retry: l }), false)) {
      var G = [{ usr: n.state, key: n.key, idx: q + 1 }, x(n)];
      n = G[0];
      G = G[1];
      try {
        u.pushState(n, "", G);
      } catch (K) {
        m.location.assign(G);
      }
      A(k);
    }
  }
  function w(a, f) {
    function l() {
      w(a, f);
    }
    var k = r.Replace, n = z(a, f);
     true ? D(n.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.replace(" + JSON.stringify(a) + ")") : 0;
    c.length && (c.call({ action: k, location: n, retry: l }), 1) || (n = [{ usr: n.state, key: n.key, idx: q }, x(n)], u.replaceState(n[0], "", n[1]), A(k));
  }
  function p(a) {
    u.go(a);
  }
  b === void 0 && (b = {});
  b = b.window;
  var m = b === void 0 ? document.defaultView : b, u = m.history, t = null;
  m.addEventListener("popstate", e);
  m.addEventListener("hashchange", function() {
    var a = h()[1];
    I(a) !== I(d) && e();
  });
  var v = r.Pop;
  b = h();
  var q = b[0], d = b[1], g = F(), c = F();
  q == null && (q = 0, u.replaceState((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, u.state, { idx: q }), ""));
  return {
    get action() {
      return v;
    },
    get location() {
      return d;
    },
    createHref: x,
    push: y,
    replace: w,
    go: p,
    back: function() {
      p(-1);
    },
    forward: function() {
      p(1);
    },
    listen: function(a) {
      return g.push(a);
    },
    block: function(a) {
      var f = c.push(a);
      c.length === 1 && m.addEventListener("beforeunload", E);
      return function() {
        f();
        c.length || m.removeEventListener("beforeunload", E);
      };
    }
  };
}
;
function createMemoryHistory(b) {
  function h(d, g) {
    g === void 0 && (g = null);
    return C((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({ pathname: t.pathname, search: "", hash: "" }, typeof d === "string" ? J(d) : d, { state: g, key: H() }));
  }
  function e(d, g, c) {
    return !q.length || (q.call({ action: d, location: g, retry: c }), false);
  }
  function x(d, g) {
    u = d;
    t = g;
    v.call({ action: u, location: t });
  }
  function z(d, g) {
    var c = r.Push, a = h(d, g);
     true ? D(t.pathname.charAt(0) === "/", "Relative pathnames are not supported in memory history.push(" + JSON.stringify(d) + ")") : 0;
    e(c, a, function() {
      z(d, g);
    }) && (m += 1, p.splice(m, p.length, a), x(c, a));
  }
  function A(d, g) {
    var c = r.Replace, a = h(d, g);
     true ? D(t.pathname.charAt(0) === "/", "Relative pathnames are not supported in memory history.replace(" + JSON.stringify(d) + ")") : 0;
    e(c, a, function() {
      A(d, g);
    }) && (p[m] = a, x(c, a));
  }
  function y(d) {
    var g = Math.min(Math.max(m + d, 0), p.length - 1), c = r.Pop, a = p[g];
    e(c, a, function() {
      y(d);
    }) && (m = g, x(c, a));
  }
  b === void 0 && (b = {});
  var w = b;
  b = w.initialEntries;
  w = w.initialIndex;
  var p = (b === void 0 ? ["/"] : b).map(function(d) {
    var g = C((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({ pathname: "/", search: "", hash: "", state: null, key: H() }, typeof d === "string" ? J(d) : d));
     true ? D(g.pathname.charAt(0) === "/", "Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: " + JSON.stringify(d) + ")") : 0;
    return g;
  }), m = Math.min(Math.max(w == null ? p.length - 1 : w, 0), p.length - 1), u = r.Pop, t = p[m], v = F(), q = F();
  return { get index() {
    return m;
  }, get action() {
    return u;
  }, get location() {
    return t;
  }, createHref: function(d) {
    return typeof d === "string" ? d : I(d);
  }, push: z, replace: A, go: y, back: function() {
    y(-1);
  }, forward: function() {
    y(1);
  }, listen: function(d) {
    return v.push(d);
  }, block: function(d) {
    return q.push(d);
  } };
}
;



/***/ }),

/***/ "./node_modules/react-router-dom/index.js":
/*!************************************************!*\
  !*** ./node_modules/react-router-dom/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MemoryRouter": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.MemoryRouter),
/* harmony export */   "Navigate": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Navigate),
/* harmony export */   "Outlet": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Outlet),
/* harmony export */   "Route": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Route),
/* harmony export */   "Router": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Router),
/* harmony export */   "Routes": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.Routes),
/* harmony export */   "UNSAFE_LocationContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_LocationContext),
/* harmony export */   "UNSAFE_NavigationContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_NavigationContext),
/* harmony export */   "UNSAFE_RouteContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_RouteContext),
/* harmony export */   "createRoutesFromChildren": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.createRoutesFromChildren),
/* harmony export */   "generatePath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.generatePath),
/* harmony export */   "matchPath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchPath),
/* harmony export */   "matchRoutes": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes),
/* harmony export */   "renderMatches": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.renderMatches),
/* harmony export */   "resolvePath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath),
/* harmony export */   "useHref": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useHref),
/* harmony export */   "useInRouterContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useInRouterContext),
/* harmony export */   "useLocation": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation),
/* harmony export */   "useMatch": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useMatch),
/* harmony export */   "useNavigate": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigate),
/* harmony export */   "useNavigationType": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigationType),
/* harmony export */   "useOutlet": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useOutlet),
/* harmony export */   "useOutletContext": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useOutletContext),
/* harmony export */   "useParams": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useParams),
/* harmony export */   "useResolvedPath": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath),
/* harmony export */   "useRoutes": () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_1__.useRoutes),
/* harmony export */   "BrowserRouter": () => (/* binding */ BrowserRouter),
/* harmony export */   "HashRouter": () => (/* binding */ HashRouter),
/* harmony export */   "Link": () => (/* binding */ Link),
/* harmony export */   "NavLink": () => (/* binding */ NavLink),
/* harmony export */   "createSearchParams": () => (/* binding */ createSearchParams),
/* harmony export */   "unstable_HistoryRouter": () => (/* binding */ HistoryRouter),
/* harmony export */   "useLinkClickHandler": () => (/* binding */ useLinkClickHandler),
/* harmony export */   "useSearchParams": () => (/* binding */ useSearchParams)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! history */ "./node_modules/history/index.js");
/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-router */ "./node_modules/react-router/index.js");
/**
 * React Router DOM v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */




function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
const _excluded = ["onClick", "reloadDocument", "replace", "state", "target", "to"], _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
function BrowserRouter(_ref) {
  let {
    basename,
    children,
    window
  } = _ref;
  let historyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  if (historyRef.current == null) {
    historyRef.current = (0,history__WEBPACK_IMPORTED_MODULE_2__.createBrowserHistory)({
      window
    });
  }
  let history = historyRef.current;
  let [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    action: history.action,
    location: history.location
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => history.listen(setState), [history]);
  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react_router__WEBPACK_IMPORTED_MODULE_1__.Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
function HashRouter(_ref2) {
  let {
    basename,
    children,
    window
  } = _ref2;
  let historyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  if (historyRef.current == null) {
    historyRef.current = (0,history__WEBPACK_IMPORTED_MODULE_2__.createHashHistory)({
      window
    });
  }
  let history = historyRef.current;
  let [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    action: history.action,
    location: history.location
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => history.listen(setState), [history]);
  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react_router__WEBPACK_IMPORTED_MODULE_1__.Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    history
  } = _ref3;
  const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    action: history.action,
    location: history.location
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => history.listen(setState), [history]);
  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react_router__WEBPACK_IMPORTED_MODULE_1__.Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
const Link = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    reloadDocument,
    replace = false,
    state,
    target,
    to
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);
  let href = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useHref)(to);
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented && !reloadDocument) {
      internalOnClick(event);
    }
  }
  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)("a", _extends({}, rest, {
    href,
    onClick: handleClick,
    ref,
    target
  }));
});
if (true) {
  Link.displayName = "Link";
}
const NavLink = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation)();
  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath)(to);
  let locationPathname = location.pathname;
  let toPathname = path.pathname;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive
    });
  } else {
    className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive
  }) : styleProp;
  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Link, _extends({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to
  }), typeof children === "function" ? children({
    isActive
  }) : children);
});
if (true) {
  NavLink.displayName = "NavLink";
}
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state
  } = _temp === void 0 ? {} : _temp;
  let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigate)();
  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation)();
  let path = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useResolvedPath)(to);
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {
    if (event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
      event.preventDefault();
      let replace = !!replaceProp || (0,history__WEBPACK_IMPORTED_MODULE_2__.createPath)(location) === (0,history__WEBPACK_IMPORTED_MODULE_2__.createPath)(path);
      navigate(to, {
        replace,
        state
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to]);
}
function useSearchParams(defaultInit) {
   true ? warning(typeof URLSearchParams !== "undefined", "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params\n\nIf you're unsure how to load polyfills, we recommend you check out https://polyfill.io/v3/ which provides some recommendations about how to load polyfills only for users that need them, instead of for every user.") : 0;
  let defaultSearchParamsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(createSearchParams(defaultInit));
  let location = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useLocation)();
  let searchParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    let searchParams2 = createSearchParams(location.search);
    for (let key of defaultSearchParamsRef.current.keys()) {
      if (!searchParams2.has(key)) {
        defaultSearchParamsRef.current.getAll(key).forEach((value) => {
          searchParams2.append(key, value);
        });
      }
    }
    return searchParams2;
  }, [location.search]);
  let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_1__.useNavigate)();
  let setSearchParams = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((nextInit, navigateOptions) => {
    navigate("?" + createSearchParams(nextInit), navigateOptions);
  }, [navigate]);
  return [searchParams, setSearchParams];
}
function createSearchParams(init) {
  if (init === void 0) {
    init = "";
  }
  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
    let value = init[key];
    return memo.concat(Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]);
  }, []));
}



/***/ }),

/***/ "./node_modules/react-router/index.js":
/*!********************************************!*\
  !*** ./node_modules/react-router/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MemoryRouter": () => (/* binding */ MemoryRouter),
/* harmony export */   "Navigate": () => (/* binding */ Navigate),
/* harmony export */   "Outlet": () => (/* binding */ Outlet),
/* harmony export */   "Route": () => (/* binding */ Route),
/* harmony export */   "Router": () => (/* binding */ Router),
/* harmony export */   "Routes": () => (/* binding */ Routes),
/* harmony export */   "UNSAFE_LocationContext": () => (/* binding */ LocationContext),
/* harmony export */   "UNSAFE_NavigationContext": () => (/* binding */ NavigationContext),
/* harmony export */   "UNSAFE_RouteContext": () => (/* binding */ RouteContext),
/* harmony export */   "createRoutesFromChildren": () => (/* binding */ createRoutesFromChildren),
/* harmony export */   "generatePath": () => (/* binding */ generatePath),
/* harmony export */   "matchPath": () => (/* binding */ matchPath),
/* harmony export */   "matchRoutes": () => (/* binding */ matchRoutes),
/* harmony export */   "renderMatches": () => (/* binding */ renderMatches),
/* harmony export */   "resolvePath": () => (/* binding */ resolvePath),
/* harmony export */   "useHref": () => (/* binding */ useHref),
/* harmony export */   "useInRouterContext": () => (/* binding */ useInRouterContext),
/* harmony export */   "useLocation": () => (/* binding */ useLocation),
/* harmony export */   "useMatch": () => (/* binding */ useMatch),
/* harmony export */   "useNavigate": () => (/* binding */ useNavigate),
/* harmony export */   "useNavigationType": () => (/* binding */ useNavigationType),
/* harmony export */   "useOutlet": () => (/* binding */ useOutlet),
/* harmony export */   "useOutletContext": () => (/* binding */ useOutletContext),
/* harmony export */   "useParams": () => (/* binding */ useParams),
/* harmony export */   "useResolvedPath": () => (/* binding */ useResolvedPath),
/* harmony export */   "useRoutes": () => (/* binding */ useRoutes)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! history */ "./node_modules/history/index.js");
/**
 * React Router v6.2.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */


function invariant(cond, message) {
  if (!cond)
    throw new Error(message);
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
const alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
     true ? warning(false, message) : 0;
  }
}
const NavigationContext = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
if (true) {
  NavigationContext.displayName = "Navigation";
}
const LocationContext = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
if (true) {
  LocationContext.displayName = "Location";
}
const RouteContext = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({
  outlet: null,
  matches: []
});
if (true) {
  RouteContext.displayName = "Route";
}
function MemoryRouter(_ref) {
  let {
    basename,
    children,
    initialEntries,
    initialIndex
  } = _ref;
  let historyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();
  if (historyRef.current == null) {
    historyRef.current = (0,history__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({
      initialEntries,
      initialIndex
    });
  }
  let history = historyRef.current;
  let [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    action: history.action,
    location: history.location
  });
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => history.listen(setState), [history]);
  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
function Navigate(_ref2) {
  let {
    to,
    replace,
    state
  } = _ref2;
  !useInRouterContext() ?  true ? invariant(false, "<Navigate> may be used only in the context of a <Router> component.") : 0 : void 0;
   true ? warning(!(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NavigationContext).static, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.") : 0;
  let navigate = useNavigate();
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    navigate(to, {
      replace,
      state
    });
  });
  return null;
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Route(_props) {
   true ? invariant(false, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : 0;
}
function Router(_ref3) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = history__WEBPACK_IMPORTED_MODULE_1__.Action.Pop,
    navigator,
    static: staticProp = false
  } = _ref3;
  !!useInRouterContext() ?  true ? invariant(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : 0 : void 0;
  let basename = normalizePathname(basenameProp);
  let navigationContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({
    basename,
    navigator,
    static: staticProp
  }), [basename, navigator, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = (0,history__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
   true ? warning(location != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash + '" because it does not start with the ') + "basename, so the <Router> won't render anything.") : 0;
  if (location == null) {
    return null;
  }
  return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(LocationContext.Provider, {
    children,
    value: {
      location,
      navigationType
    }
  }));
}
function Routes(_ref4) {
  let {
    children,
    location
  } = _ref4;
  return useRoutes(createRoutesFromChildren(children), location);
}
function useHref(to) {
  !useInRouterContext() ?  true ? invariant(false, "useHref() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    basename,
    navigator
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to);
  let joinedPathname = pathname;
  if (basename !== "/") {
    let toPathname = getToPathname(to);
    let endsWithSlash = toPathname != null && toPathname.endsWith("/");
    joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
  }
  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ?  true ? invariant(false, "useLocation() may be used only in the context of a <Router> component.") : 0 : void 0;
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LocationContext).location;
}
function useNavigationType() {
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LocationContext).navigationType;
}
function useMatch(pattern) {
  !useInRouterContext() ?  true ? invariant(false, "useMatch() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    pathname
  } = useLocation();
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => matchPath(pattern, pathname), [pathname, pattern]);
}
function useNavigate() {
  !useInRouterContext() ?  true ? invariant(false, "useNavigate() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    basename,
    navigator
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NavigationContext);
  let {
    matches
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  let activeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    activeRef.current = true;
  });
  let navigate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(to, options) {
    if (options === void 0) {
      options = {};
    }
     true ? warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered.") : 0;
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);
    if (basename !== "/") {
      path.pathname = joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator.replace : navigator.push)(path, options.state);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
const OutletContext = /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);
function useOutletContext() {
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(OutletContext);
}
function useOutlet(context) {
  let outlet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
function useParams() {
  let {
    matches
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to) {
  let {
    matches
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
}
function useRoutes(routes, locationArg) {
  !useInRouterContext() ?  true ? invariant(false, "useRoutes() may be used only in the context of a <Router> component.") : 0 : void 0;
  let {
    matches: parentMatches
  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (true) {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')) : 0 : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  if (true) {
     true ? warning(parentRoute || matches != null, 'No routes matched location "' + location.pathname + location.search + location.hash + '" ') : 0;
     true ? warning(matches == null || matches[matches.length - 1].route.element !== void 0, 'Matched leaf route at location "' + location.pathname + location.search + location.hash + '" does not have an element. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.') : 0;
  }
  return _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase, match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
  })), parentMatches);
}
function createRoutesFromChildren(children) {
  let routes = [];
  react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, (element) => {
    if (!/* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(element)) {
      return;
    }
    if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children));
      return;
    }
    !(element.type === Route) ?  true ? invariant(false, "[" + (typeof element.type === "string" ? element.type : element.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : 0 : void 0;
    let route = {
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children);
    }
    routes.push(route);
  });
  return routes;
}
function generatePath(path, params) {
  if (params === void 0) {
    params = {};
  }
  return path.replace(/:(\w+)/g, (_, key) => {
    !(params[key] != null) ?  true ? invariant(false, 'Missing ":' + key + '" param') : 0 : void 0;
    return params[key];
  }).replace(/\/*\*$/, (_) => params["*"] == null ? "" : params["*"].replace(/^\/*/, "/"));
}
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i], pathname);
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  routes.forEach((route, index) => {
    let meta = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      !meta.relativePath.startsWith(parentPath) ?  true ? invariant(false, 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.") : 0 : void 0;
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      !(route.index !== true) ?  true ? invariant(false, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')) : 0 : void 0;
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s) => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? a[a.length - 1] - b[b.length - 1] : 0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: joinPaths([matchedPathname, match.pathnameBase]),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function renderMatches(matches) {
  return _renderMatches(matches);
}
function _renderMatches(matches, parentMatches) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null)
    return null;
  return matches.reduceRight((outlet, match, index) => {
    return /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(RouteContext.Provider, {
      children: match.route.element !== void 0 ? match.route.element : /* @__PURE__ */ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Outlet, null),
      value: {
        outlet,
        matches: parentMatches.concat(matches.slice(0, index + 1))
      }
    });
  }, null);
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
   true ? warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".')) : 0;
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else {
    regexpSource += end ? "\\/*$" : "(?:\\b|\\/|$)";
  }
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
     true ? warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ").")) : 0;
    return value;
  }
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_1__.parsePath)(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function resolveTo(toArg, routePathnames, locationPathname) {
  let to = typeof toArg === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_1__.parsePath)(toArg) : toArg;
  let toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname;
  let from;
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
    path.pathname += "/";
  }
  return path;
}
function getToPathname(to) {
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? (0,history__WEBPACK_IMPORTED_MODULE_1__.parsePath)(to).pathname : to.pathname;
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let nextChar = pathname.charAt(basename.length);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(basename.length) || "/";
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;



/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _extends)
/* harmony export */ });
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}


/***/ })

}]);